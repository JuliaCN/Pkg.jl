var documenterSearchIndex = {"docs":
[{"location":"basedocs/","page":"Pkg","title":"Pkg","text":"EditURL = \"https://github.com/ioxera/Pkg.jl/blob/master/docs/src/basedocs.md\"","category":"page"},{"location":"basedocs/#Pkg","page":"Pkg","title":"Pkg","text":"","category":"section"},{"location":"basedocs/","page":"Pkg","title":"Pkg","text":"Pkg 是Julia内建的包管理器，用于处理安装，更新，移除包等操作。","category":"page"},{"location":"basedocs/","page":"Pkg","title":"Pkg","text":"note: Note\n下面是Pkg的简短介绍。更详细的信息位于 Project.toml 和 Manifest.toml 文件， 包括包版本兼容性([compat])，环境，注册表等信息。高度建议阅读完整手册，可以访问： https://pkgdocs.julialang.org.","category":"page"},{"location":"basedocs/","page":"Pkg","title":"Pkg","text":"import Markdown\nfile = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\nstr = read(file, String)\nstr = replace(str, r\"^#.*$\"m => \"\")\nstr = replace(str, \"[API Reference](@ref)\" => \"[API Reference](https://pkgdocs.julialang.org/v1/api/)\")\nstr = replace(str, \"(@ref Working-with-Environments)\" => \"(https://pkgdocs.julialang.org/v1/environments/)\")\nstr = replace(str, \"(@ref Managing-Packages)\" => \"(https://pkgdocs.julialang.org/v1/managing-packages/)\")\nMarkdown.parse(str)","category":"page"},{"location":"artifacts/#Artifacts","page":"8. Artifacts","title":"8. Artifacts","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Pkg 可以安装和管理数据容器，它不是 Julia 包。这些容器可以包含特定于平台的二进制文件、数据集、文本或任何其他类型的数据，这些数据可以方便地放置在不可变的、具有生命周期的数据存储中。这些容器（称为“Artifacts”）可以在本地创建、托管在任何地方，并在安装 Julia 包时自动下载和解包。此机制还为使用BinaryBuilder.jl 进行包构建提供二进制依赖。","category":"page"},{"location":"artifacts/#基本用法","page":"8. Artifacts","title":"基本用法","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Pkg artifacts 在Artifacts.toml文件中声明，该文件可以放在当前目录或包的根目录中。目前，Pkg 支持从 URL 下载 tar 文件（可以压缩）。以下是一个最小 Artifacts.toml 文件，它允许从 github.com 下载 socrates.tar.gz 文件。在此示例中，定义了一个名为 socrates 的 artifact。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"# a simple Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"如果 Artifacts.toml 文件位于您的当前目录中，则 socrates.tar.gz 可以下载、解压缩，并以 artifact\"socrates\" 方式使用。由于这个 tar 压缩包包含一个 bin 文件夹和一个名为 socrates 的文本文件，我们可以按如下方式访问该文件的内容。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using Pkg.Artifacts\n\nrootpath = artifact\"socrates\"\nopen(joinpath(rootpath, \"bin\", \"socrates\")) do file\n    println(read(file, String))\nend","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"如果您有一个可通过 url 访问的现有 tar 压缩包，也可以以这种方式访问​​它。要创建 Artifacts.toml 您必须计算两个哈希值：下载文件的 sha256 哈希值和解压内容的 git-tree-sha1 哈希值。这些可以计算如下：","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using Tar, Inflate, SHA\n\nfilename = \"socrates.tar.gz\"\nprintln(\"sha256: \", bytes2hex(open(sha256, filename)))\nprintln(\"git-tree-sha1: \", Tar.tree_hash(IOBuffer(inflate_gzip(filename))))","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"要从您创建的包中访问此 artifact，请将 Artifacts.toml 放在包的根目录中，和 Project.toml 相邻。然后，确保在您的 deps 节中添加了 Pkg，以及在 compat 节中设置 julia = \"1.3\" 或更高版本。","category":"page"},{"location":"artifacts/#Artifacts.toml-文件","page":"8. Artifacts","title":"Artifacts.toml 文件","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Pkg 提供了用于使用 artifacts 的 API，以及用于记录软件包中 artifacts 使用情况的 TOML 文件格式，并在软件包安装时自动下载 artifacts。Artifacts 始终可以通过内容哈希来引用，但通常通过绑定到项目源树中 Artifacts.toml 文件的内容哈希的名称来访问。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"note: Note\n可以使用替代名称 JuliaArtifacts.toml，类似于分别使用 JuliaProject.toml 和 JuliaManifest.toml 代替 Project.toml 和 Manifest.toml。 It is possible to use the alternate name JuliaArtifacts.toml, similar to how it is possible to use JuliaProject.toml and JuliaManifest.toml instead of Project.toml and Manifest.toml, respectively.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"此处显示了一个 Artifacts.toml 文件示例：","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"# Example Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\nlazy = true\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.bz2\"\n    sha256 = \"13fc17b97be41763b02cbb80e9d048302cec3bd3d446c2ed6e8210bddcd3ac76\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"4bdf4556050cb55b67b211d4e78009aaec378cbc\"\nlibc = \"musl\"\nos = \"linux\"\n\n    [[c_simple.download]]\n    sha256 = \"411d6befd49942826ea1e59041bddf7dbb72fb871bb03165bf4e164b13ab5130\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-linux-musl.tar.gz\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"51264dbc770cd38aeb15f93536c29dc38c727e4c\"\nos = \"macos\"\n\n    [[c_simple.download]]\n    sha256 = \"6c17d9e1dc95ba86ec7462637824afe7a25b8509cc51453f0eb86eda03ed4dc3\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-apple-darwin14.tar.gz\"\n\n[processed_output]\ngit-tree-sha1 = \"1c223e66f1a8e0fae1f9fcb9d3f2e3ce48a82200\"","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"此 Artifacts.toml 绑定了三个 artifacts：一个命名为 socrates，一个命名为 c_simple，一个命名为 processed_output。artifacts 唯一需要的信息是它的 git-tree-sha1。因为 artifacts 仅通过其内容哈希寻址，所以 Artifacts.toml 文件的目的是提供有关这些 artifacts 的元数据，例如绑定人类可读的名称到内容哈希，提供有关可以从何处下载 artifacts 的信息，甚至绑定单个名称到多个哈希，由特定于平台的约束（例如操作系统或 libgfortran 的版本）键控(keyed)。","category":"page"},{"location":"artifacts/#Artifact-类型和属性","page":"8. Artifacts","title":"Artifact 类型和属性","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"在上面的示例中，socrates artifact 展示了具有多个下载位置的独立于平台的 artifact。下载和安装 socrates artifact 时，将按顺序尝试 URL 直到成功。该socrates artifact 被标记为 lazy，这意味着它不会在安装包含的包时自动下载，而是在包第一次尝试使用它时按需下载。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"c_simple artifact 展示了一个依赖于平台的 artifact，其中 c_simple 数组中的每个条目都包含键，键帮助调用包根据主机的详细信息选择适当的下载地址。请注意，每个 artifact 都包含对应下载条目的 git-tree-sha1 和 sha256。这是为了确保下载的 tar 压缩包在尝试解压缩之前是安全的，并强制所有 tar 压缩包必须扩展为同样的整体 git 树哈希。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"processed_output artifact不包含 download 节，因此无法被安装。像这样的 artifact 是先前运行的代码的结果，生成一个新的 artifact 并将生成的哈希绑定到该项目中的名称上。","category":"page"},{"location":"artifacts/#使用-Artifacts","page":"8. Artifacts","title":"使用 Artifacts","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"可以使用从 Pkg.Artifacts 命名空间公开的便捷 API 来操作 artifact 。作为一个激励性的例子，让我们想象我们正在编写一个需要加载 Iris 机器学习数据集的包。虽然我们可以在构建步骤中将数据集下载到包目录中，并且目前许多包都这样做，但这有一些明显的缺点：","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"首先，它修改了包目录，使包安装变得具有状态了，这是我们要避免的。将来，我们希望能够以完全只读的方式安装包，而不是在安装后能够自行修改。\n其次，下载的数据不会在包的不同版本之间共享。如果我们安装了三个不同版本的包以供不同项目使用，那么我们需要三个不同的数据副本，即使这些版本之间没有更改。此外，每次我们升级或降级软件包时，除非我们做了一些聪明的事情（而且可能很脆弱），否则我们必须再次下载数据。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"对于 artifacts，我们将检查 iris artifacts 是否已经存在于磁盘上，只有不存在时我们才会下载并安装它，之后我们可以将结果绑定到我们的 Artifacts.toml 文件中：","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using Pkg.Artifacts\n\n# This is the path to the Artifacts.toml we will manipulate\nartifact_toml = joinpath(@__DIR__, \"Artifacts.toml\")\n\n# Query the `Artifacts.toml` file for the hash bound to the name \"iris\"\n# (returns `nothing` if no such binding exists)\niris_hash = artifact_hash(\"iris\", artifact_toml)\n\n# If the name was not bound, or the hash it was bound to does not exist, create it!\nif iris_hash == nothing || !artifact_exists(iris_hash)\n    # create_artifact() returns the content-hash of the artifact directory once we're finished creating it\n    iris_hash = create_artifact() do artifact_dir\n        # We create the artifact by simply downloading a few files into the new artifact directory\n        iris_url_base = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris\"\n        download(\"$(iris_url_base)/iris.data\", joinpath(artifact_dir, \"iris.csv\"))\n        download(\"$(iris_url_base)/bezdekIris.data\", joinpath(artifact_dir, \"bezdekIris.csv\"))\n        download(\"$(iris_url_base)/iris.names\", joinpath(artifact_dir, \"iris.names\"))\n    end\n\n    # Now bind that hash within our `Artifacts.toml`.  `force = true` means that if it already exists,\n    # just overwrite with the new content-hash.  Unless the source files change, we do not expect\n    # the content hash to change, so this should not cause unnecessary version control churn.\n    bind_artifact!(artifact_toml, \"iris\", iris_hash)\nend\n\n# Get the path of the iris dataset, either newly created or previously generated.\n# this should be something like `~/.julia/artifacts/dbd04e28be047a54fbe9bf67e934be5b5e0d357a`\niris_dataset_path = artifact_path(iris_hash)","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"对于使用先前绑定的 artifacts 的特定用例，我们有一个速记符号 artifact\"name\"，它将自动搜索当前包中的 Artifacts.toml 文件，按名称查找给定的 artifacts，如果尚未安装，则安装它，然后返回该给定 artifacts 的路径。下面给出了这个速记符号的一个例子：","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using Pkg.Artifacts\n\n# For this to work, an `Artifacts.toml` file must be in the current working directory\n# (or in the root of the current package) and must define a mapping for the \"iris\"\n# artifact.  If it does not exist on-disk, it will be downloaded.\niris_dataset_path = artifact\"iris\"","category":"page"},{"location":"artifacts/#Pkg.Artifacts-API","page":"8. Artifacts","title":"Pkg.Artifacts API","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Artifacts API 分为三个级别：哈希感知函数、名称感知函数和实用函数。 The Artifacts API is broken up into three levels: hash-aware functions, name-aware functions and utility functions.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"哈希感知函数只处理内容哈希。这些方法允许您查询 artifact 是否存在、其路径是什么、验证 artifact 是否满足其在磁盘上的内容哈希等。哈希感知函数包括：artifact_exists()、artifact_path()、remove_artifact()、verify_artifact()和 archive_artifact()。请注意，通常您不应该使用 remove_artifact()，而应该使用 Pkg.gc() 来清理安装的 artifact。\n名称感知函数处理 Artifacts.toml 文件中的绑定名称，因此，通常需要 Artifacts.toml 文件路径和 artifact 名称。名称感知函数包括：artifact_meta()、artifact_hash()、bind_artifact!()、unbind_artifact!()、download_artifact() 和 ensure_artifact_installed()。\n实用函数处理 artifact 生命周期的各种方面，例如 create_artifact()、ensure_all_artifacts_installed()，甚至是 @artifact_str 字符串宏。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"有关文档字符串和方法的完整列表，请参阅 Artifacts Reference章节。","category":"page"},{"location":"artifacts/#覆盖-artifact-位置","page":"8. Artifacts","title":"覆盖 artifact 位置","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"有时需要能够覆盖 artifact 的位置和内容。一个常见的例子是计算环境，其中必须使用某些版本的二进制依赖项，而不管包是使用哪个版本的依赖项发布的。虽然典型的 Julia 配置会下载、解包并链接到通用库，但系统管理员可能希望禁用此功能，而使用已安装在本地计算机上的库。Pkg 通过在 artifacts depot 目录中放置一个 Overrides.toml 文件启用对此功能的支持（例如对于默认用户仓库是 ~/.julia/artifacts/Overrides.toml 文件），它可以通过内容哈希，或包的 UUID 和绑定到 artifact 的名称覆盖 artifact 的位置。此外，目标位置可以是绝对路径，也可以是 artifact 内容哈希。这允许系统管理员创建他们自己的 artifacts，然后他们可以通过覆盖其他包来使用新 artifact。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"# Override single hash to an absolute path\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/replacement\"\n\n# Override single hash to new artifact content-hash\n683942669b4639019be7631caa28c38f3e1924fe = \"d826e316b6c0d29d9ad0875af6ca63bf67ed38c3\"\n\n# Override package bindings by specifying the package UUID and bound artifact name\n# For demonstration purposes we assume this package is called `Foo`\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"/path/to/libfoo\"\nlibbar = \"683942669b4639019be7631caa28c38f3e1924fe\"","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"由于Pkg depot 的分层特性，多个 Overrides.toml 文件可能同时生效。这允许“内部” Overrides.toml 文件覆盖放在“外部” Overrides.toml 文件中的覆盖规则。要删除覆盖并重新启用 artifact 的默认位置逻辑，请将条目映射插入到空字符串中：","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/new/replacement\"\n683942669b4639019be7631caa28c38f3e1924fe = \"\"\n\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"\"","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"如果上面给出的两个 Overrides.toml 片段相互叠加，最终结果将映射内容哈希 78f35e74ff113f02274ce60dab6e92b4546ef806 到 \"/path/to/new/replacement\"，并映射 Foo.libbar 到由内容哈希标识的 artifact 683942669b4639019be7631caa28c38f3e1924fe。请注意，虽然该哈希之前已被覆盖，但它不再被覆盖，因此 Foo.libbar 将直接查看 ~/.julia/artifacts/683942669b4639019be7631caa28c38f3e1924fe 位置。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"大多数受覆盖影响的方法可以通过设置它们的 honor_overrides=false 关键字参数来忽略覆盖。要使基于 UUID/名称 的覆盖起作用，Artifacts.toml 文件必须在知道加载包的 UUID 的情况下被加载。这是由 artifacts\"\" 字符串宏自动推导出来的，但是，如果您出于某种原因在包中手动使用 Pkg.Artifacts API 并且希望尊重覆盖，则必须通过关键字参数将包的 UUID 提供给 API 调用，类似于 artifact_meta() 和 ensure_artifact_installed() 使用 pkg_uuid 关键字参数。","category":"page"},{"location":"artifacts/#扩展平台选择","page":"8. Artifacts","title":"扩展平台选择","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"compat: Julia 1.7\nPkg 的扩展平台选择至少需要 Julia 1.7，并且被认为是实验性的。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Julia 1.6 中的新增功能，Platform 对象可以应用扩展属性，允许使用诸如 CUDA 驱动程序版本兼容性、微架构兼容性、julia 版本兼容性等扩展属性标记 artifacts！请注意，此功能被认为是实验性的，将来可能会更改。如果您作为包开发人员发现自己需要此功能，请与我们联系，以便它可以为整个生态系统的利益而发展。为了在 Pkg.add() 时支持 artifact 选择，Pkg 将运行特殊命名的文件 <project_root>/.pkg/select_artifacts.jl，传递当前平台三元组作为第一个参数。这个 artifact 选择脚本应该打印一个 TOML - 表示此包根据给定平台需要的 artifacts 的序列化字典，如果给定平台三元组未明确提供平台功能，则根据需要对系统进行任何检查，以自动检测平台功能。字典的格式应该与从 Artifacts.select_downloadable_artifacts() 返回的匹配，实际上大多数包应该简单地用一个增强的 Platform 对象调用此函数。artifact 选择 hook 的定义的示例，可能如下所示，分为两个文件：","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"# .pkg/platform_augmentation.jl\nusing Libdl, Base.BinaryPlatforms\nfunction augment_platform!(p::Platform)\n    # If this platform object already has a `cuda` tag set, don't augment\n    if haskey(p, \"cuda\")\n        return p\n    end\n\n    # Open libcuda explicitly, so it gets `dlclose()`'ed after we're done\n    dlopen(\"libcuda\") do lib\n        # find symbol to ask for driver version; if we can't find it, just silently continue\n        cuDriverGetVersion = dlsym(lib, \"cuDriverGetVersion\"; throw_error=false)\n        if cuDriverGetVersion !== nothing\n            # Interrogate CUDA driver for driver version:\n            driverVersion = Ref{Cint}()\n            ccall(cuDriverGetVersion, UInt32, (Ptr{Cint},), driverVersion)\n\n            # Store only the major version\n            p[\"cuda\"] = div(driverVersion, 1000)\n        end\n    end\n\n    # Return possibly-altered `Platform` object\n    return p\nend","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using TOML, Artifacts, Base.BinaryPlatforms\ninclude(\"./platform_augmentation.jl\")\nartifacts_toml = joinpath(dirname(@__DIR__), \"Artifacts.toml\")\n\n# Get \"target triplet\" from ARGS, if given (defaulting to the host triplet otherwise)\ntarget_triplet = get(ARGS, 1, Base.BinaryPlatforms.host_triplet())\n\n# Augment this platform object with any special tags we require\nplatform = augment_platform!(HostPlatform(parse(Platform, target_triplet)))\n\n# Select all downloadable artifacts that match that platform\nartifacts = select_downloadable_artifacts(artifacts_toml; platform)\n\n# Output the result to `stdout` as a TOML dictionary\nTOML.print(stdout, artifacts)","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"在此 hook 定义中，我们的 platformaugmentation 例程打开一个系统库(libcuda)，搜索 CUDA 驱动的版本符号，然后将版本号中的主版本号嵌入到我们要增强的 Platform 对象的 cuda 属性中。虽然实际尝试关闭已加载的库对于此代码而言并不重要（因为它很可能会在包操作完成后，立即被 CUDA 包再次打开），但最佳实践是使 hook 尽可能轻量级和透明，因为它们将来可能会被其他 Pkg 实用程序使用。在您自己的包中，您也应该在使用 `@artifactstr` 宏时使用增强的平台对象，如下所示：","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"include(\"../.pkg/platform_augmentation.jl\")\n\nfunction __init__()\n    p = augment_platform!(HostPlatform())\n    global my_artifact_dir = @artifact_str(\"MyArtifact\", p)\nend","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"这可确保您的代码使用与 Pkg 尝试安装的 artifact 相同的 artifact。","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Artifact 选择 hook 仅允许使用Base、Artifacts、Libdl 和 TOML 包。不允许使用任何其他标准库，也不允许使用任何包（包括他们所属的包）。","category":"page"},{"location":"toml-files/#Project-and-Manifest","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Pkg 的两个核心文件是 Project.toml 和 Manifest.toml。Project.toml 和 Manifest.toml 都是用 TOML（因此是 .toml 扩展名）编写的，包括有关依赖项、版本、包名称、UUID 等的信息。","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"note: Note\nProject.toml 和 Manifest.toml 文件不仅由包管理器使用；Julia 的代码加载也使用它们，并确定例如 using Example 应该做什么。有关更多详细信息，请参阅 Julia 手册中有关 代码加载 的部分。","category":"page"},{"location":"toml-files/#Project.toml","page":"10. Project.toml and Manifest.toml","title":"Project.toml","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"项目文件从高层次上描述了项目，例如，项目文件中列出了包/项目的依赖关系和兼容性约束。文件条目如下所述。","category":"page"},{"location":"toml-files/#authors-字段","page":"10. Project.toml and Manifest.toml","title":"authors 字段","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"对于包，authors 可选字段是描述包作者的字符串列表，格式为 NAME <EMAIL>。例如：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"authors = [\"Some One <someone@email.com>\",\n           \"Foo Bar <foo@bar.com>\"]","category":"page"},{"location":"toml-files/#name-字段","page":"10. Project.toml and Manifest.toml","title":"name 字段","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"包/项目的名称由 name 字段决定，例如：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"name = \"Example\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"名称必须是有效标识符（不以数字开头且既不是 true 也不是的 false  Unicode 字符序列）。对于包，建议遵循 包命名准则。name 字段对于包是必需的。","category":"page"},{"location":"toml-files/#uuid-字段","page":"10. Project.toml and Manifest.toml","title":"uuid 字段","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"uuid 是包/项目 通用唯一标识符 字符串，例如：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"uuid 字段对于包是必需的。","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"note: Note\n建议使用 UUIDs.uuid4() 生成随机 UUID。","category":"page"},{"location":"toml-files/#version-字段","page":"10. Project.toml and Manifest.toml","title":"version 字段","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"version 是包/项目版本号的字符串。它应该由三个数字组成：主要版本号、次要版本号和补丁号，用 . 分隔，例如：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"version = \"1.2.5\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Julia 使用语义版本控制(SemVer)，该 version 字段应遵循 SemVer。基本规则是：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"在 1.0.0 之前，一切正常，但是当您进行重大更改时，次要版本应该增加。\n在 1.0.0 之后，仅在增加主要版本时进行重大更改。\n在 1.0.0 之后，如果不增加次要版本，则不应添加新的公共 API。这尤其包括来自 Base 或其他包的新类型、函数、方法和方法重载 。","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"另请参阅兼容性部分。","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"请注意，当涉及到 1.0.0 之前的版本时，Pkg.jl 偏离了 SemVer 规范。有关详细信息，请参阅 pre-1.0 行为 部分。","category":"page"},{"location":"toml-files/#[deps]-节","page":"10. Project.toml and Manifest.toml","title":"[deps] 节","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"该节列出了包/项目的所有依赖项[deps]。每个依赖项都以“名称-uuid”对的形式列出，例如：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"通常不需要手动向 [deps] 节添加条目；这由 Pkg 操作来处理，例如 add。","category":"page"},{"location":"toml-files/#[compat]-节","page":"10. Project.toml and Manifest.toml","title":"[compat] 节","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[deps] 下面列出的依赖项的兼容性约束可以在该 [compat] 节中列出。例子：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[compat]\nExample = \"1.2\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"兼容性章节详细描述了不同的可能兼容性约束。也可以列出 julia 自身的约束，尽管 julia 未在 [deps] 节中列为依赖项：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[compat]\njulia = \"1.1\"","category":"page"},{"location":"toml-files/#Manifest.toml","page":"10. Project.toml and Manifest.toml","title":"Manifest.toml","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"manifest 文件是环境中包状态的绝对记录。它包括有关项目（直接和间接）依赖项的确切信息。给定一对 Project.toml 和 Manifest.toml，可以实例化完全相同的包环境，这对于可复现性非常有用。有关详细信息，请参阅 Pkg.instantiate。","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"note: Note\nManifest.toml 文件由 Pkg 生成和维护，一般情况下，不应手动修改此文件。","category":"page"},{"location":"toml-files/#Manifest.toml-条目","page":"10. Project.toml and Manifest.toml","title":"Manifest.toml 条目","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"manifest 中有三个顶级条目，如下所示：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"julia_version = \"1.8.2\"\nmanifest_format = \"2.0\"\nproject_hash = \"4d9d5b552a1236d3c1171abf88d59da3aaac328a\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"这显示了创建 manifest 的 Julia 版本、manifest 的“格式”和项目文件的哈希值，这样就可以看到 manifest 与项目文件相比什么时候过时了。","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"每个依赖项在 manifest 文件中都有自己的节，其内容根据依赖项添加到环境的方式而有所不同。每个依赖项的节都包含以下条目的组合：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"uuid: 依赖项的 UUID，例如 uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"。\ndeps: 一个向量，列出依赖项的依赖项，例如 deps = [\"Example\", \"JSON\"]。\nversion: 版本号，例如 version = \"1.2.6\"。\npath: 源代码的文件路径，例如 path = /home/user/Example。\nrepo-url: 源代码存储库的 URL ，例如 repo-url = \"https://github.com/JuliaLang/Example.jl.git\"。\nrepo-rev: git 存储库的修订版, 例如一个分支 repo-rev = \"master\" 或一个提交 repo-rev = \"66607a62a83cb07ab18c0b35c038fcd62987c9b1\"。\ngit-tree-sha1: git 源码树的哈希， 例如 git-tree-sha1 = \"ca3820cc4e66f473467d912c4b2b3ae5dc968444\"。","category":"page"},{"location":"toml-files/#已添加的包","page":"10. Project.toml and Manifest.toml","title":"已添加的包","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"当从包注册表添加包时，例如通过调用 pkg> add Example 或使用特定版本 pkg> add Example@1.2，生成的 Manifest.toml 条目如下所示：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.3\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"请特别注意，没有 repo-url 存在，因为该信息包含在能够找到此包的注册表中。","category":"page"},{"location":"toml-files/#按分支添加的包","page":"10. Project.toml and Manifest.toml","title":"按分支添加的包","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"添加由分支指定的包时生成的 [deps] 节，例如 pkg> add Example#masteror 或 pkg> add https://github.com/JuliaLang/Example.jl.git，如下所示：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"master\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"请注意，我们正在跟踪的分支 (master) 和远程存储库 url (\"https://github.com/JuliaLang/Example.jl.git\") 都存储在 manifest 中。","category":"page"},{"location":"toml-files/#按提交添加的包","page":"10. Project.toml and Manifest.toml","title":"按提交添加的包","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"添加由提交指定的包时生成的 [deps] 节，例如 pkg> add Example#cf6ba6cc0be0bb5f56840188563579d67048be34，如下所示：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"cf6ba6cc0be0bb5f56840188563579d67048be34\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"与跟踪分支的唯一区别是 repo-rev 的内容。","category":"page"},{"location":"toml-files/#开发包","page":"10. Project.toml and Manifest.toml","title":"开发包","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"使用 develop 命令添加包时生成的 [deps] 节，例如 pkg> develop Example 或 pkg> develop /path/to/local/folder/Example，如下所示：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\npath = \"/home/user/.julia/dev/Example/\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"请注意，包含源代码的路径，并且直接反映对该源代码树所做的更改。","category":"page"},{"location":"toml-files/#已固定的包","page":"10. Project.toml and Manifest.toml","title":"已固定的包","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"已固定的包也记录在 manifest 文件中，例如由 pkg> add Example; pin Example 生成的 [deps] 节如下所示：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[deps.Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\npinned = true\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"唯一的不同是附加了 pinned = true 条目。","category":"page"},{"location":"toml-files/#多个同名的包","page":"10. Project.toml and Manifest.toml","title":"多个同名的包","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Julia 根据 UUID 区分包，这意味着仅靠名称不足以识别包。在同一个环境中可以有多个包具有相同的名称，但具有不同的 UUID。在这种情况下，Manifest.toml 文件看起来有点不同。例如，考虑您已将包 A 和 B 添加到您的环境的情况，文件 Project.toml 如下所示：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[deps]\nA = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\nB = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"如果 A 现在依赖于 B = \"f41f7b98-334e-11e9-1257-49272045fb24\"，即另一个名为 B 的包，在 Manifest.toml 文件中将有两个不同的 B 包。在这种情况下，为清楚起见删除了 git-tree-sha1 和 version 字段的完整 Manifest.toml 文件如下所示：","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[deps.A]]\nuuid = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\n\n    [deps.A.deps]\n    B = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n\n[[deps.B]]\nuuid = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n[[deps.B]]\nuuid = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"现在，有一个包含两个 B 包的数组，并且 A 包的 [deps] 节已扩展为明确说明 A 依赖于哪个 B 包。","category":"page"},{"location":"compatibility/#Compatibility","page":"6. 兼容性","title":"6. 兼容性","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"兼容性是指，限制你的项目兼容依赖包的版本的能力。如果未给出依赖包的兼容性，则假定项目与该依赖包的所有版本兼容。","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"在 Project.toml 文件中输入依赖包的兼容性，例如：","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\njulia = \"1.6\"\nExample = \"0.5\"","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"将兼容性条目放入项目文件后，up 命令可用于使它生效。","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"下面详细描述版本说明符的格式。","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"info: Info\n使用 compat 命令编辑 Pkg REPL 中的兼容条目，或手动编辑项目文件。","category":"page"},{"location":"compatibility/#版本说明符格式","page":"6. 兼容性","title":"版本说明符格式","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"与其他包管理器类似，Julia 包管理器尊重语义版本控制(semver)。作为示例，假定版本说明符 1.2.3 与版本 [1.2.3 - 2.0.0)（) 指非闭合上界）是兼容的。更确切地说，版本说明符要么是插入(caret)说明符，例如 ^1.2.3， 要么是波浪(tilde)说明符，例如 ~1.2.3。插入说明符是默认值，因此 1.2.3 == ^1.2.3。插入符号和波浪号之间的区别将在下一节中描述。多个版本说明符的并集可以通过逗号分隔各个版本说明符来组成，例如","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nExample = \"1.2, 3\"","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"将得到 [1.2.0, 3.0.0)。请注意，前导零的处理方式不同，例如 Example = \"0.2, 1\" 只会得到 [0.2.0 - 0.3.0) ∪ [1.0.0 - 2.0.0)。有关带前导零的版本号的更多信息，请参阅下一节。","category":"page"},{"location":"compatibility/#compat-pre-1.0","page":"6. 兼容性","title":"带前导零版本号的行为(0.0.x 和 0.x.y)","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"虽然 semver 规范说所有主要版本为 0 的版本（1.0.0 之前的版本）彼此不兼容，但我们决定仅在主要和次要版本号都为零时应用它。换句话说，0.0.1 和 0.0.2 被认为是不兼容的。具有非零次要版本号（0.a.b 且 a != 0）的 pre-1.0 版本，被认为与具有相同次要版本号，以及较小或相等补丁版本号（0.a.c 且 c <= b）的版本兼容；即，版本 0.2.2、0.2.3 与 0.2.1、0.2.0 兼容。主要版本号为 0 及次要版本号不相同的版本被认为是不兼容的，因此版本 0.3.0 可能与 0.2.0 相比具有重大更改。为此， [compat] 条目：","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nExample = \"0.0.1\"","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"得到 Example 的版本边界为 [0.0.1, 0.0.2)（仅相当于版本 0.0.1），而[compat] 条目：","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nExample = \"0.2.1\"","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"得到 Example 的版本边界为 [0.2.1, 0.3.0)。","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"特别是，当一个包与 0.2.3 相比具有附加功能时，它可能设置 version = \"0.2.4\"，只要它保持与 0.2.0 的向后兼容。另请参见version 字段。","category":"page"},{"location":"compatibility/#插入说明符","page":"6. 兼容性","title":"插入说明符","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"插入符号 (^) 说明符允许根据 semver 规则兼容的升级。如果没有使用说明符，这是默认行为。如果新版本没有修改版本说明符中最左边的非零数字，则更新的依赖项被认为是兼容的。","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"一些示例如下所示。","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nPkgA = \"^1.2.3\" # [1.2.3, 2.0.0)\nPkgB = \"^1.2\"   # [1.2.0, 2.0.0)\nPkgC = \"^1\"     # [1.0.0, 2.0.0)\nPkgD = \"^0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"^0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"^0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"^0\"     # [0.0.0, 1.0.0)","category":"page"},{"location":"compatibility/#波浪符说明符","page":"6. 兼容性","title":"波浪符说明符","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"波浪号说明符提供更有限的升级可能性。当指定了主要、次要和补丁版本号时，或指定了主要和次要版本号时，只允许更改补丁版本。如果您只指定一个主要版本，则允许升级次要版本号和补丁版本号（~1 因此等同于 ^1）。例如：","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nPkgA = \"~1.2.3\" # [1.2.3, 1.3.0)\nPkgB = \"~1.2\"   # [1.2.0, 1.3.0)\nPkgC = \"~1\"     # [1.0.0, 2.0.0)\nPkgD = \"~0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"~0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"~0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"~0\"     # [0.0.0, 1.0.0)","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"对于主要版本号为 0 的所有版本，波浪说明符和插入说明符是等效的。","category":"page"},{"location":"compatibility/#相等说明符","page":"6. 兼容性","title":"相等说明符","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"相等说明符可用于指定具体的版本：","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nPkgA = \"=1.2.3\"           # [1.2.3, 1.2.3]\nPkgA = \"=0.10.1, =0.10.3\" # 0.10.1 or 0.10.3","category":"page"},{"location":"compatibility/#不等说明符","page":"6. 兼容性","title":"不等说明符","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"不等式也可用于指定版本范围：","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nPkgB = \">= 1.2.3\" # [1.2.3,  ∞)\nPkgC = \"≥ 1.2.3\"  # [1.2.3,  ∞)\nPkgD = \"< 1.2.3\"  # [0.0.0, 1.2.3) = [0.0.0, 1.2.2]","category":"page"},{"location":"compatibility/#连字说明符","page":"6. 兼容性","title":"连字说明符","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"连字符语法也可用于指定版本范围。确保连字符的两边都有空格。","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nPkgA = \"1.2.3 - 4.5.6\" # [1.2.3, 4.5.6]\nPkgA = \"0.2.3 - 4.5.6\" # [0.2.3, 4.5.6]","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"第一个端点中任何未指定的尾随数字都被视为零：","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nPkgA = \"1.2 - 4.5.6\"   # [1.2.0, 4.5.6]\nPkgA = \"1 - 4.5.6\"     # [1.0.0, 4.5.6]\nPkgA = \"0.2 - 4.5.6\"   # [0.2.0, 4.5.6]\nPkgA = \"0.2 - 0.5.6\"   # [0.2.0, 0.5.6]","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"第二个端点中任何未指定的尾随数字将被视为通配符：","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nPkgA = \"1.2.3 - 4.5\"   # 1.2.3 - 4.5.* = [1.2.3, 4.6.0)\nPkgA = \"1.2.3 - 4\"     # 1.2.3 - 4.*.* = [1.2.3, 5.0.0)\nPkgA = \"1.2 - 4.5\"     # 1.2.0 - 4.5.* = [1.2.0, 4.6.0)\nPkgA = \"1.2 - 4\"       # 1.2.0 - 4.*.* = [1.2.0, 5.0.0)\nPkgA = \"1 - 4.5\"       # 1.0.0 - 4.5.* = [1.0.0, 4.6.0)\nPkgA = \"1 - 4\"         # 1.0.0 - 4.*.* = [1.0.0, 5.0.0)\nPkgA = \"0.2.3 - 4.5\"   # 0.2.3 - 4.5.* = [0.2.3, 4.6.0)\nPkgA = \"0.2.3 - 4\"     # 0.2.3 - 4.*.* = [0.2.3, 5.0.0)\nPkgA = \"0.2 - 4.5\"     # 0.2.0 - 4.5.* = [0.2.0, 4.6.0)\nPkgA = \"0.2 - 4\"       # 0.2.0 - 4.*.* = [0.2.0, 5.0.0)\nPkgA = \"0.2 - 0.5\"     # 0.2.0 - 0.5.* = [0.2.0, 0.6.0)\nPkgA = \"0.2 - 0\"       # 0.2.0 - 0.*.* = [0.2.0, 1.0.0)","category":"page"},{"location":"compatibility/#修复冲突","page":"6. 兼容性","title":"修复冲突","text":"","category":"section"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"版本冲突之前是通过 example 介绍的，该冲突是由包 D 被其他两个包 B 和 C 使用产生的冲突。我们对错误消息的分析显示 B 使用了 D 的过时版本。要修复它，首先要尝试的是 pkg> dev B以便您可以修改 B 及其兼容性要求。如果您在编辑器中打开它的 Project.toml 文件，您可能会注意到类似","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nD = \"0.1\"","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"通常第一步是将其修改为类似","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"[compat]\nD = \"0.1, 0.2\"","category":"page"},{"location":"compatibility/","page":"6. 兼容性","title":"6. 兼容性","text":"这表示 B 兼容 0.1 和 0.2 版本；如果你执行 pkg> up，这会修复包错误。但是，您首先需要解决一个主要问题：可能在 D 的 v0.2 版本中存在和 B 不兼容的更改。在继续之前，您应该更新所有包，然后运行 B​​ 的测试，扫描 pkg> test B 的输出以确保 D 的 v0.2 版本实际上正在使用 。（可能有一个 D 的额外的依赖关系将其固定到 v0.1，并且您不希望被误导以为您已经在新版本上测试了 B。）如果使用了新版本并且测试仍然通过，您可以假设B不需要任何特性更新以适应 D 的 v0.2 版本; 您可以安全地将此更改作为拉取请求提交到 B 以便发布新版本。相反，如果抛出错误，则表明 B 需要更广泛的更新以兼容 D 的最新版本。需要完成这些更新，才能同时使用 A 和 B。但是，您可以继续彼此独立地使用它们。","category":"page"},{"location":"getting-started/#**2.**-入门","page":"2. 入门","title":"2. 入门","text":"","category":"section"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"以下是对 Pkg 基本功能的快速概述。它应该可以帮助新用户熟悉基本的 Pkg 功能，例如添加和删除包以及使用环境。  ","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"note: Note\n本节省略了一些 Pkg 输出，以保持基本指南的重点。这将有助于保持良好的节奏，避免陷入细节的困境中。如果您需要更多详细信息，请参阅 Pkg 手册的后续部分。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"note: Note\n本指南使用 Pkg REPL 执行 Pkg 命令。对于非交互式使用，我们推荐使用 Pkg API。Pkg API 完整记录在 Pkg 文档的API Reference部分。","category":"page"},{"location":"getting-started/#基本用法","page":"2. 入门","title":"基本用法","text":"","category":"section"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"Pkg 带有一个 REPL。在 Julia REPL 中按 ] 进入 Pkg REPL。要返回 Julia REPL，请按 Ctrl+C 或 backspace（当 REPL 光标位于输入的开头时）。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"进入 Pkg REPL 后，您应该会看到以下提示：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg>","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"要添加包，使用 add:","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] + Example v0.5.3","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"安装包后，可以将其加载到 Julia 会话中：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"julia> import Example\n\njulia> Example.hello(\"friend\")\n\"Hello, friend\"","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"还可以一次指定多个包进行安装：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> add JSON StaticArrays","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"status 命令 (或更短的 st 命令) 可以用于查看已安装的包.","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> st\nStatus `~/.julia/environments/v1.6/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3\n  [90137ffa] StaticArrays v1.5.9","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"note: Note\n某些 Pkg REPL 命令具有长版本和短版本，例如status and st。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"要移除包，使用 rm (或 remove):","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> rm JSON StaticArrays","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"使用 up (或 update) 来更新已安装的包：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> up","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"如果您一直遵循本指南，则安装的软件包可能是最新版本，因此 up 不会执行任何操作。下面展示在故意安装旧版本的示例包，然后升级它的情况下的状态输出：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> st\nStatus `~/.julia/environments/v1.8/Project.toml`\n⌃ [7876af07] Example v0.5.1\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n(@v1.8) pkg> up\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ↑ Example v0.5.1 ⇒ v0.5.3","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"我们可以看到状态输出告诉我们有更新的版本可用并且 up 升级了包。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"有关管理包的更多信息，请参阅文档的 管理包 部分。","category":"page"},{"location":"getting-started/#环境入门","page":"2. 入门","title":"环境入门","text":"","category":"section"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"目前为止，我们已经介绍了基本的包管理：添加、更新和删除包。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"您可能已经注意到 REPL 提示符中的 (@v1.8)。这让我们知道 v1.8是活动环境。不同的环境可以安装完全不同的包和版本。活动环境是将被 Pkg 命令修改的环境，例如 add,rm 和 update。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"让我们建立一个新环境，以便进行实验。要设置活动环境，请使用 activate：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> activate tutorial\n[ Info: activating new environment at `~/tutorial/Project.toml`.","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"Pkg 让我们知道我们正在创建一个新环境，并且该环境将存储在~/tutorial目录中。环境的路径是相对于 REPL 的当前工作目录创建的。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"Pkg 还更新了 REPL 提示符以反映新的活动环境：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(tutorial) pkg>","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"我们可以使用 status 命令查询有关活动环境的信息:","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(tutorial) pkg> status\n    Status `~/tutorial/Project.toml`\n   (empty environment)","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"~/tutorial/Project.toml 是活动环境的项目文件。项目文件是一个TOML文件，Pkg 在这里存储已显式安装的包。请注意，这个新环境是空的。让我们添加一些包并观察：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(tutorial) pkg> add Example JSON\n...\n\n(tutorial) pkg> status\n    Status `~/tutorial/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"我们可以看到 tutorial 环境现在包含 Example 和 JSON。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"note: Note\n如果您在多个环境中安装了相同的软件包（相同版本），则该软件包只会被下载并存储在硬盘上一次。这使得环境非常轻量级并且可以有效地自由创建。仅使用包含大量包的默认环境是 Julia 初学者的常见错误。学习如何有效地使用环境将改善您使用 Julia 包的体验。","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"有关环境的更多信息，请参阅文档的 使用“环境” 部分。","category":"page"},{"location":"getting-started/#寻求帮助","page":"2. 入门","title":"寻求帮助","text":"","category":"section"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"如果您遇到困难，可以寻求 Pkg 帮助：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> ?","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"您应该会看到可用命令列表以及简短说明。您可以通过指定命令来寻求更详细的帮助：","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"(@v1.8) pkg> ?develop","category":"page"},{"location":"getting-started/","page":"2. 入门","title":"2. 入门","text":"本指南应该可以帮助您开始使用 Pkg。 Pkg 在强大的包管理方面提供更多功能，请阅读完整手册以了解更多信息！","category":"page"},{"location":"registries/#**7.**-注册表","page":"7. 注册表","title":"7. 注册表","text":"","category":"section"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"注册表包含有关软件包的信息，例如可用的版本和依赖项，以及可以下载它们的位置。如果没有安装其他注册表，则 General注册表 默认被自动安装。","category":"page"},{"location":"registries/#管理注册表","page":"7. 注册表","title":"管理注册表","text":"","category":"section"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"可以从 Pkg REPL 或使用函数式 API 添加、移除和更新注册表。在本节中，我们将描述 REPL 接口。注册表 API 记录在Registry API Reference 部分。","category":"page"},{"location":"registries/#添加注册表","page":"7. 注册表","title":"添加注册表","text":"","category":"section"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"可以在 Pkg REPL 中使用 registry add 命令添加自定义注册表。这通常通过一个指向注册表的 URL 来完成。","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"如果安装自定义注册表导致 General 注册表没有自动安装，手动指定它也很容易：它会被自动添加。在这种情况下，可以很容易地添加 General：","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"pkg> registry add General","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"现在所有 General 中注册的包都是可用的，例如从 General 中添加包。要查看当前安装了哪些注册表，您可以使用 registry status （或 registry st）命令：","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"pkg> registry st\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"注册表总是添加到 user depot，位于 DEPOT_PATH 的第一个条目（参见词汇表章节）。","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"note: 来自包服务器的注册表\n包服务器可能会宣传额外可用的包注册表。当 Pkg 运行在一个使用 JULIA_PKG_SERVER 环境变量配置自定义包服务器的，干净的 Julia depot 中时（例如在一个新安装之后），所有可用的注册表都会被自动添加。如果 depot 已经安装了一些注册表（例如 General），额外的注册表可以使用无参数 registry add 命令轻松安装。","category":"page"},{"location":"registries/#移除注册表","page":"7. 注册表","title":"移除注册表","text":"","category":"section"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"可以使用 registry remove（或 registry rm）命令移除注册表。这里我们移除 General 注册表：","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"pkg> registry rm General\n  Removing registry `General` from ~/.julia/registries/General\n\npkg> registry st\nRegistry Status\n  (no registries found)","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"如果有多个名为 General 的已安装注册表，您必须使用 uuid 消除歧义，就像在操作包时一样，例如：","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"pkg> registry rm General=23338594-aafe-5451-b93e-139f81909106\n  Removing registry `General` from ~/.julia/registries/General","category":"page"},{"location":"registries/#更新注册表","page":"7. 注册表","title":"更新注册表","text":"","category":"section"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"registry update（或registry up）命令可用于更新注册表。这里我们更新 General 注册表：","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"pkg> registry up General\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"要更新所有已安装的注册表，只需执行以下操作：","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"pkg> registry up\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`","category":"page"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"执行包操作时，注册表会在每个会话中自动更新一次，因此很少需要手动执行。","category":"page"},{"location":"registries/#创建和维护注册表","page":"7. 注册表","title":"创建和维护注册表","text":"","category":"section"},{"location":"registries/","page":"7. 注册表","title":"7. 注册表","text":"Pkg 只为注册表提供客户端工具，而不是创建或维护它们的功能。但是，Registrator.jl 和LocalRegistry.jl 提供了创建和更新注册表的方法，而 RegistryCI.jl 提供了用于维护注册表的自动化测试和合并功能。","category":"page"},{"location":"glossary/#Glossary","page":"9. 词汇表","title":"9. 词汇表","text":"","category":"section"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Project（项目）: 具有标准布局的源代码树，包括存放主体 Julia 代码的 src 目录、测试项目的 test 目录、存放文档文件的 docs 目录，以及可选的存放构建脚本及其输出的deps 目录。一个项目通常也会有一个项目文件，并且可以选择有一个 manifest 文件：","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Project file（项目文件）: 项目根目录中的文件，名为 Project.toml（或 JuliaProject.toml），描述有关项目的元数据，包括其名称、UUID（用于包）、作者、许可证以及它所依赖的包和库的名称和 UUID上。\nManifest file（manifest 文件）: 项目根目录中的一个文件，名为 Manifest.toml（或 JuliaManifest.toml），描述了项目使用的每个包和库的完整依赖关系图和确切版本。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Package（包）: 提供可重用功能的项目，其他 Julia 项目可以通过 import X 或 using X 使用。一个包应该有一个项目文件，其中包含一个 uuid 条目提供此包的 UUID 。此 UUID 用于在依赖它的项目中的标识此包。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"note: Note\n由于遗留原因，可以从 REPL 或脚本的顶层加载没有项目文件或 UUID 的包。但是，无法从带有项目文件或 UUID 的项目中加载没有项目文件的包。一旦你从项目文件加载后，一切都需要项目文件和 UUID。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Application（应用程序）: 提供具有独立功能的项目，此项目不打算被其他 Julia 项目重用。例如，Web 应用程序或命令行实用程序，或科学论文随附的模拟/分析代码。应用程序也可能有一个 UUID ，但是并不需要它。应用程序还可以为其所依赖的包提供全局配置选项。另一方面，包可能不提供全局配置，因为这可能与主应用程序的配置冲突。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"note: Note\nProjects vs. Packages vs. Applications:Project 是一个概括行的术语：packages 和 applications 是 projects 的种类。\nPackages 应该有 UUID, applications 也可以有 UUID，但是并不需要它。\nApplications 可以提供全局配置, 而 packages 不能。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Environment（环境）: 项目文件提供的顶级名称映射与依赖关系图的组合，以及从包到 manifest 文件提供的入口点的映射。有关更多详细信息，请参阅有关代码加载的手册部分。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Explicit environment（显式环境）: 形式上的环境指，显式项目文件和可选的对应 manifest 文件同在一个目录中。如果 manifest 文件不存在，则隐含的依赖图和位置映射都为空。\nImplicit environment（隐式环境）: 作为目录提供的环境（没有项目文件或 menifest 文件），其中包含入口点形式为 X.jl、X.jl/src/X.jl 或 X/src/X.jl 的包。这些入口点隐含了顶级名称映射。这些包目录中存在的项目文件暗示了依赖关系图，例如 X.jl/Project.toml 或 X/Project.toml。如果有项目文件的话，X包的依赖项是对应项目文件中的依赖项。位置映射由入口点本身隐含。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Registry（注册表）: 具有标准布局的源码树，记录一组已注册包的元数据、可用的版本标签、以及哪些版本的包相互兼容或不兼容。注册表按包名称和 UUID 进行索引，并且每个注册包都有一个目录，提供它的以下元数据：","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"name – e.g. DataFrames\nUUID – e.g. a93c6f00-e57d-5684-b7b6-d8193f3e46c0\nrepository – e.g. https://github.com/JuliaData/DataFrames.jl.git\nversions – 所有已注册版本标签的列表","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"对于包的每个注册版本，都提供以下信息：","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"它的语义版本号 – e.g. v1.2.3\n它的 git tree SHA-1 哈希 – e.g. 7ffb18ea3245ef98e368b02b81e8a86543a11103\n从名称到依赖项的 UUID 的映射\n它与其他软件包的哪些版本兼容/不兼容","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"依赖项和兼容性使用已压缩但人类可读的包版本区间格式存储。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Depot: 系统上的一个目录，其中包含各种与包相关的资源，包括：","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"environments: 共享命名环境 (e.g. v1.0, devtools)\nclones: 包存储库的裸克隆\ncompiled: 缓存的已编译包镜像 (.ji files)\nconfig: 全局配置文件 (e.g. startup.jl)\ndev: 包开发的默认目录\nlogs: 日志文件 (e.g. manifest_usage.toml, repl_history.jl)\npackages: 已安装的包版本\nregistries: 注册表的克隆 (e.g. General)","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Load path: 一个 environments 栈，在其中搜索包标识符、包依赖项和入口点。加载路径在 Julia 中由 LOAD_PATH 全局变量控制，该变量在启动时根据环境变量 JULIA_LOAD_PATH 的值填充。第一个条目是您的主要环境，通常是当前项目，而后面的条目提供了可能希望从 REPL 或顶级脚本中使用的附加包。","category":"page"},{"location":"glossary/","page":"9. 词汇表","title":"9. 词汇表","text":"Depot path: 一个 depot 位置栈，包含包管理器以及 Julia 的代码加载机制，在其中查找注册表、已安装包、命名环境、存储库克隆、缓存的编译包镜像和配置文件。depot path 由 Julia 的 DEPOT_PATH 全局变量控制，该变量在启动时根据 JULIA_DEPOT_PATH 环境变量的值设置。第一个条目是“user depot”，当前用户应当具有写入权和所有权。user depot 位于：克隆的注册表，安装的新版本包，创建和更新的命名环境，克隆的包存储库，保存的新编译的包镜像文件，写入的日志文件，默认检出（checked out）的开发包，以及保存的全局配置数据。depot path 中的后续条目被视为只读，适用于由系统管理员安装和管理的注册表、包等。","category":"page"},{"location":"api/#API-Reference","page":"12. API Reference","title":"12. API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"This section describes the functional API for interacting with Pkg.jl. It is recommended to use the functional API, rather than the Pkg REPL mode, for non-interactive usage, for example in scripts.","category":"page"},{"location":"api/#General-API-Reference","page":"12. API Reference","title":"General API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"Certain options are generally useful and can be specified in any API call. You can specify these options by setting keyword arguments.","category":"page"},{"location":"api/#Redirecting-output","page":"12. API Reference","title":"Redirecting output","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"Use the io::IOBuffer keyword argument to redirect Pkg output. For example, Pkg.add(\"Example\"; io=devnull) will discard any output produced by the add call.","category":"page"},{"location":"api/#Package-API-Reference","page":"12. API Reference","title":"Package API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"In the Pkg REPL mode, packages (with associated version, UUID, URL etc) are parsed from strings, for example \"Package#master\",\"Package@v0.1\", \"www.mypkg.com/MyPkg#my/feature\".","category":"page"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"In the functional API, it is possible to use strings as arguments for simple commands (like Pkg.add([\"PackageA\", \"PackageB\"]), but more complicated commands, which e.g. specify URLs or version range, require the use of a more structured format over strings. This is done by creating an instance of PackageSpec which is passed in to functions.","category":"page"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"Pkg.add\nPkg.develop\nPkg.activate\nPkg.rm\nPkg.update\nPkg.test\nPkg.build\nPkg.pin\nPkg.free\nPkg.instantiate\nPkg.resolve\nPkg.gc\nPkg.status\nPkg.compat\nPkg.precompile\nPkg.offline\nPkg.why\nPkg.dependencies\nPkg.respect_sysimage_versions\nPkg.project\nPkg.undo\nPkg.redo\nPkg.setprotocol!\nPackageSpec\nPackageMode\nUpgradeLevel","category":"page"},{"location":"api/#Pkg.add","page":"12. API Reference","title":"Pkg.add","text":"Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED)\nPkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED)\n\nAdd a package to the current project. This package will be available by using the import and using keywords in the Julia REPL, and if the current project is a package, also inside that package.\n\nResolution Tiers\n\nPkg resolves the set of packages in your environment using a tiered algorithm. The preserve keyword argument allows you to key into a specific tier in the resolve algorithm. The following table describes the argument values for preserve (in order of strictness):\n\nValue Description\nPRESERVE_ALL Preserve the state of all existing dependencies (including recursive dependencies)\nPRESERVE_DIRECT Preserve the state of all existing direct dependencies\nPRESERVE_SEMVER Preserve semver-compatible versions of direct dependencies\nPRESERVE_NONE Do not attempt to preserve any version information\nPRESERVE_TIERED Use the tier which will preserve the most version information (this is the default)\n\nExamples\n\nPkg.add(\"Example\") # Add a package from registry\nPkg.add(\"Example\"; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and preserve existing dependencies\nPkg.add(name=\"Example\", version=\"0.3\") # Specify version; latest release in the 0.3 series\nPkg.add(name=\"Example\", version=\"0.3.1\") # Specify version; exact release\nPkg.add(url=\"https://github.com/JuliaLang/Example.jl\", rev=\"master\") # From url to remote gitrepo\nPkg.add(url=\"/remote/mycompany/juliapackages/OurPackage\") # From path to local gitrepo\nPkg.add(url=\"https://github.com/Company/MonoRepo\", subdir=\"juliapkgs/Package.jl)\") # With subdir\n\nAfter the installation of new packages the project will be precompiled. See more at Environment Precompilation.\n\nSee also PackageSpec, Pkg.develop.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.develop","page":"12. API Reference","title":"Pkg.develop","text":"Pkg.develop(pkg::Union{String, Vector{String}}; io::IO=stderr)\nPkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}}; io::IO=stderr)\n\nMake a package available for development by tracking it by path. If pkg is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable JULIA_PKG_DEVDIR, with joinpath(DEPOT_PATH[1],\"dev\") being the default.\n\nIf pkg is given as a local path, the package at that path will be tracked.\n\nExamples\n\n# By name\nPkg.develop(\"Example\")\n\n# By url\nPkg.develop(url=\"https://github.com/JuliaLang/Compat.jl\")\n\n# By path\nPkg.develop(path=\"MyJuliaPackages/Package.jl\")\n\nSee also PackageSpec, Pkg.add.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.activate","page":"12. API Reference","title":"Pkg.activate","text":"Pkg.activate([s::String]; shared::Bool=false, io::IO=stderr)\nPkg.activate(; temp::Bool=false, shared::Bool=false, io::IO=stderr)\n\nActivate the environment at s. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:\n\nIf shared is true, the first existing environment named s from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.\nIf temp is true this will create and activate a temporary environment which will be deleted when the julia process is exited.\nIf s is an existing path, then activate the environment at that path.\nIf s is a package in the current project and s is tracking a path, then activate the environment at the tracked path.\nOtherwise, s is interpreted as a non-existing path, which is then activated.\n\nIf no argument is given to activate, then activate the home project. The home project is specified by either the --project command line option to the julia executable, or the JULIA_PROJECT environment variable.\n\nExamples\n\nPkg.activate()\nPkg.activate(\"local/path\")\nPkg.activate(\"MyDependency\")\nPkg.activate(; temp=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.rm","page":"12. API Reference","title":"Pkg.rm","text":"Pkg.rm(pkg::Union{String, Vector{String}}; mode::PackageMode = PKGMODE_PROJECT)\nPkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}}; mode::PackageMode = PKGMODE_PROJECT)\n\nRemove a package from the current project. If mode is equal to PKGMODE_MANIFEST also remove it from the manifest including all recursive dependencies of pkg.\n\nSee also PackageSpec, PackageMode.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.update","page":"12. API Reference","title":"Pkg.update","text":"Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT, preserve::PreserveLevel)\nPkg.update(pkg::Union{String, Vector{String}})\nPkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})\n\nIf no posistional argument is given, update all packages in the manifest if mode is PKGMODE_MANIFEST and packages in both manifest and project if mode is PKGMODE_PROJECT. If no positional argument is given, level can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).\n\nIf packages are given as positional arguments, the preserve argument can be used to control what other packages are allowed to update:\n\nPRESERVE_ALL (default): Only allow pkg to update.\nPRESERVE_DIRECT: Only allow pkg and indirect dependencies that are not a direct dependency in the project to update.\nPRESERVE_NONE: Allow pkg and all its indirect dependencies to update.\n\nAfter any package updates the project will be precompiled. See more at Environment Precompilation.\n\nSee also PackageSpec, PackageMode, UpgradeLevel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.test","page":"12. API Reference","title":"Pkg.test","text":"Pkg.test(; kwargs...)\nPkg.test(pkg::Union{String, Vector{String}; kwargs...)\nPkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)\n\nKeyword arguments:\n\ncoverage::Bool=false: enable or disable generation of coverage statistics.\nallow_reresolve::Bool=true: allow Pkg to reresolve the package versions in the test environment\njulia_args::Union{Cmd, Vector{String}}: options to be passed the test process.\ntest_args::Union{Cmd, Vector{String}}: test arguments (ARGS) available in the test process.\n\ncompat: Julia 1.9\nallow_reresolve requires at least Julia 1.9.\n\nRun the tests for package pkg, or for the current project (which thus needs to be a package) if no positional argument is given to Pkg.test. A package is tested by running its test/runtests.jl file.\n\nThe tests are run by generating a temporary environment with only the pkg package and its (recursive) dependencies in it. If a manifest file exists and the allow_reresolve keyword argument is set to false, the versions in the manifest file are used. Otherwise a feasible set of packages is resolved and installed.\n\nDuring the tests, test-specific dependencies are active, which are given in the project file as e.g.\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]\n\nThe tests are executed in a new process with check-bounds=yes and by default startup-file=no. If using the startup file (~/.julia/config/startup.jl) is desired, start julia with --startup-file=yes. Inlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with --inline=no.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.build","page":"12. API Reference","title":"Pkg.build","text":"Pkg.build(; verbose = false, io::IO=stderr)\nPkg.build(pkg::Union{String, Vector{String}}; verbose = false, io::IO=stderr)\nPkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false, io::IO=stderr)\n\nRun the build script in deps/build.jl for pkg and all of its dependencies in depth-first recursive order. If no argument is given to build, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time. verbose = true prints the build output to stdout/stderr instead of redirecting to the build.log file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.pin","page":"12. API Reference","title":"Pkg.pin","text":"Pkg.pin(pkg::Union{String, Vector{String}}; io::IO=stderr)\nPkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr)\n\nPin a package to the current version (or the one given in the PackageSpec) or to a certain git revision. A pinned package is never updated.\n\nExamples\n\nPkg.pin(\"Example\")\nPkg.pin(name=\"Example\", version=\"0.3.1\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.free","page":"12. API Reference","title":"Pkg.free","text":"Pkg.free(pkg::Union{String, Vector{String}}; io::IO=stderr)\nPkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr)\n\nIf pkg is pinned, remove the pin. If pkg is tracking a path, e.g. after Pkg.develop, go back to tracking registered versions.\n\nExamples\n\nPkg.free(\"Package\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.instantiate","page":"12. API Reference","title":"Pkg.instantiate","text":"Pkg.instantiate(; verbose = false, io::IO=stderr)\n\nIf a Manifest.toml file exists in the active project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the Project.toml files and install them. verbose = true prints the build output to stdout/stderr instead of redirecting to the build.log file. If no Project.toml exist in the current active project, create one with all the dependencies in the manifest and instantiate the resulting project.\n\nAfter packages have been installed the project will be precompiled. See more at Environment Precompilation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.resolve","page":"12. API Reference","title":"Pkg.resolve","text":"Pkg.resolve(; io::IO=stderr)\n\nUpdate the current manifest with potential changes to the dependency graph from packages that are tracking a path.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.gc","page":"12. API Reference","title":"Pkg.gc","text":"Pkg.gc(; collect_delay::Period=Day(7), io::IO=stderr)\n\nGarbage-collect package and artifact installations by sweeping over all known Manifest.toml and Artifacts.toml files, noting those that have been deleted, and then finding artifacts and packages that are thereafter not used by any other projects, marking them as \"orphaned\".  This method will only remove orphaned objects (package versions, artifacts, and scratch spaces) that have been continually un-used for a period of collect_delay; which defaults to seven days.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.status","page":"12. API Reference","title":"Pkg.status","text":"Pkg.status([pkgs...]; outdated::Bool=false, mode::PackageMode=PKGMODE_PROJECT, diff::Bool=false, compat::Bool=false, io::IO=stdout)\n\nPrint out the status of the project/manifest.\n\nPackages marked with ⌃ have new versions that can be installed, e.g. via Pkg.up. Those marked with ⌅ have new versions available, but cannot be installed due to compatibility conflicts with other packages. To see why, set the keyword argument outdated=true.\n\nSetting outdated=true will only show packages that are not on the latest version, their maximum version and why they are not on the latest version (either due to other packages holding them back due to compatibility constraints, or due to compatibility in the project file). As an example, a status output like:\n\npkg> Pkg.status(; outdated=true)\nStatus `Manifest.toml`\n⌃ [a8cc5b0e] Crayons v2.0.0 [<v3.0.0], (<v4.0.4)\n⌅ [b8a86587] NearestNeighbors v0.4.8 (<v0.4.9) [compat]\n⌅ [2ab3a3ac] LogExpFunctions v0.2.5 (<v0.3.0): SpecialFunctions\n\nmeans that the latest version of Crayons is 4.0.4 but the latest version compatible with the [compat] section in the current project is 3.0.0. The latest version of NearestNeighbors is 0.4.9 but due to compat constrains in the project it is held back to 0.4.8. The latest version of LogExpFunctions is 0.3.0 but SpecialFunctions is holding it back to 0.2.5.\n\nIf mode is PKGMODE_PROJECT, print out status only about the packages that are in the project (explicitly added). If mode is PKGMODE_MANIFEST, print status also about those in the manifest (recursive dependencies). If there are any packages listed as arguments, the output will be limited to those packages.\n\nSetting diff=true will, if the environment is in a git repository, limit the output to the difference as compared to the last git commit.\n\nSee Pkg.project and Pkg.dependencies to get the project/manifest status as a Julia object instead of printing it.\n\ncompat: Julia 1.8\nThe ⌃ and ⌅ indicators were added in Julia 1.8. The outdated keyword argument requires at least Julia 1.8.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.compat","page":"12. API Reference","title":"Pkg.compat","text":"Pkg.compat()\n\nInteractively edit the [compat] entries within the current Project.\n\nPkg.compat(pkg::String, compat::String)\n\nSet the [compat] string for the given package within the current Project.\n\nSee Compatibility for more information on the project [compat] section.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.precompile","page":"12. API Reference","title":"Pkg.precompile","text":"Pkg.precompile(; strict::Bool=false)\nPkg.precompile(pkg; strict::Bool=false)\nPkg.precompile(pkgs; strict::Bool=false)\n\nPrecompile all or specific dependencies of the project in parallel.\n\nnote: Note\nErrors will only throw when precompiling the top-level dependencies, given that not all manifest dependencies may be loaded by the top-level dependencies on the given system. This can be overridden to make errors in all dependencies throw by setting the kwarg strict to true\n\nnote: Note\nThis method is called automatically after any Pkg action that changes the manifest. Any packages that have previously errored during precompilation won't be retried in auto mode until they have changed. To disable automatic precompilation set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0. To manually control the number of tasks used set ENV[\"JULIA_NUM_PRECOMPILE_TASKS\"].\n\ncompat: Julia 1.8\nSpecifying packages to precompile requires at least Julia 1.8.\n\nExamples\n\nPkg.precompile()\nPkg.precompile(\"Foo\")\nPkg.precompile([\"Foo\", \"Bar\"])\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.offline","page":"12. API Reference","title":"Pkg.offline","text":"Pkg.offline(b::Bool=true)\n\nEnable (b=true) or disable (b=false) offline mode.\n\nIn offline mode Pkg tries to do as much as possible without connecting to internet. For example, when adding a package Pkg only considers versions that are already downloaded in version resolution.\n\nTo work in offline mode across Julia sessions you can set the environment variable JULIA_PKG_OFFLINE to \"true\".\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.why","page":"12. API Reference","title":"Pkg.why","text":"Pkg.why(pkg::Union{String, Vector{String}})\nPkg.why(pkg::Union{PackageSpec, Vector{PackageSpec}})\n\nShow the reason why this package is in the manifest. The output is a the different way to reach the package through the dependency graph starting from the dependencies.\n\ncompat: Julia 1.9\nThis function requires at least Julia 1.9.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.dependencies","page":"12. API Reference","title":"Pkg.dependencies","text":"Pkg.dependencies()::Dict{UUID, PackageInfo}\n\nThis feature is considered experimental.\n\nQuery the dependency graph of the active project. The result is a Dict that maps a package UUID to a PackageInfo struct representing the dependency (a package).\n\nPackageInfo fields\n\nField Description\nname The name of the package\nversion The version of the package (this is Nothing for stdlibs)\ntree_hash A file hash of the package directory tree\nis_direct_dep The package is a direct dependency\nis_pinned Whether a package is pinned\nis_tracking_path Whether a package is tracking a path\nis_tracking_repo Whether a package is tracking a repository\nis_tracking_registry Whether a package is being tracked by registry i.e. not by path nor by repository\ngit_revision The git revision when tracking by repository\ngit_source The git source when tracking by repository\nsource The directory containing the source code for that package\ndependencies The dependencies of that package as a vector of UUIDs\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.respect_sysimage_versions","page":"12. API Reference","title":"Pkg.respect_sysimage_versions","text":"Pkg.respect_sysimage_versions(b::Bool=true)\n\nEnable (b=true) or disable (b=false) respecting versions that are in the sysimage (enabled by default).\n\nIf this option is enabled, Pkg will only install packages that have been put into the sysimage (e.g. via PackageCompiler) at the version of the package in the sysimage. Also, trying to add a package at a URL or develop a package that is in the sysimage will error.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.project","page":"12. API Reference","title":"Pkg.project","text":"Pkg.project()::ProjectInfo\n\nThis feature is considered experimental.\n\nRequest a ProjectInfo struct which contains information about the active project.\n\nProjectInfo fields\n\nField Description\nname The project's name\nuuid The project's UUID\nversion The project's version\nispackage Whether the project is a package (has a name and uuid)\ndependencies The project's direct dependencies as a Dict which maps dependency name to dependency UUID\npath The location of the project file which defines the active project\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.undo","page":"12. API Reference","title":"Pkg.undo","text":"undo()\n\nUndoes the latest change to the active project. Only states in the current session are stored, up to a maximum of 50 states.\n\nSee also: redo.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.redo","page":"12. API Reference","title":"Pkg.redo","text":"redo()\n\nRedoes the changes from the latest undo.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.setprotocol!","page":"12. API Reference","title":"Pkg.setprotocol!","text":"setprotocol!(;\n    domain::AbstractString = \"github.com\",\n    protocol::Union{Nothing, AbstractString}=nothing\n)\n\nSet the protocol used to access hosted packages when adding a url or developing a package. Defaults to delegating the choice to the package developer (protocol === nothing). Other choices for protocol are \"https\" or \"git\".\n\nExamples\n\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = \"ssh\")\n\njulia> Pkg.setprotocol!(domain = \"gitlab.mycompany.com\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.PackageSpec","page":"12. API Reference","title":"Pkg.PackageSpec","text":"PackageSpec(name::String, [uuid::UUID, version::VersionNumber])\nPackageSpec(; name, url, path, subdir, rev, version, mode, level)\n\nA PackageSpec is a representation of a package with various metadata. This includes:\n\nThe name of the package.\nThe package's unique uuid.\nA version (for example when adding a package). When upgrading, can also be an instance of the enum UpgradeLevel.\nA url and an optional git revision. rev can be a branch name or a git commit SHA1.\nA local path. This is equivalent to using the url argument but can be more descriptive.\nA subdir which can be used when adding a package that is not in the root of a repository.\n\nMost functions in Pkg take a Vector of PackageSpec and do the operation on all the packages in the vector.\n\nMany functions that take a PackageSpec or a Vector{PackageSpec} can be called with a more concise notation with NamedTuples. For example, Pkg.add can be called either as the explicit or concise versions as:\n\nExplicit Concise\nPkg.add(PackageSpec(name=\"Package\")) Pkg.add(name = \"Package\")\nPkg.add(PackageSpec(url=\"www.myhost.com/MyPkg\"))) Pkg.add(name = \"Package\")\nPkg.add([PackageSpec(name=\"Package\"), PackageSpec(path=\"/MyPkg\"]) Pkg.add([(;name=\"Package\"), (;path=\"MyPkg\")])\n\nBelow is a comparison between the REPL mode and the functional API:\n\nREPL API\nPackage PackageSpec(\"Package\")\nPackage@0.2 PackageSpec(name=\"Package\", version=\"0.2\")\nPackage=a67d... PackageSpec(name=\"Package\", uuid=\"a67d...\")\nPackage#master PackageSpec(name=\"Package\", rev=\"master\")\nlocal/path#feature PackageSpec(path=\"local/path\"; rev=\"feature\")\nwww.mypkg.com PackageSpec(url=\"www.mypkg.com\")\n--major Package PackageSpec(name=\"Package\", version=UPLEVEL_MAJOR)\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.PackageMode","page":"12. API Reference","title":"Pkg.PackageMode","text":"PackageMode\n\nAn enum with the instances\n\nPKGMODE_MANIFEST\nPKGMODE_PROJECT\n\nDetermines if operations should be made on a project or manifest level. Used as an argument to Pkg.rm, Pkg.update and Pkg.status.\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.UpgradeLevel","page":"12. API Reference","title":"Pkg.UpgradeLevel","text":"UpgradeLevel\n\nAn enum with the instances\n\nUPLEVEL_FIXED\nUPLEVEL_PATCH\nUPLEVEL_MINOR\nUPLEVEL_MAJOR\n\nDetermines how much a package is allowed to be updated. Used as an argument to  PackageSpec or as an argument to Pkg.update.\n\n\n\n\n\n","category":"type"},{"location":"api/#Registry-API-Reference","page":"12. API Reference","title":"Registry API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"The functional API for registries uses RegistrySpecs, similar to PackageSpec.","category":"page"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"RegistrySpec\nPkg.Registry.add\nPkg.Registry.rm\nPkg.Registry.update\nPkg.Registry.status","category":"page"},{"location":"api/#Pkg.RegistrySpec","page":"12. API Reference","title":"Pkg.RegistrySpec","text":"RegistrySpec(name::String)\nRegistrySpec(; name, url, path)\n\nA RegistrySpec is a representation of a registry with various metadata, much like PackageSpec.\n\nMost registry functions in Pkg take a Vector of RegistrySpec and do the operation on all the registries in the vector.\n\nExamples\n\nBelow is a comparison between the REPL mode and the functional API::\n\nREPL API\nRegistry RegistrySpec(\"Registry\")\nRegistry=a67d... RegistrySpec(name=\"Registry\", uuid=\"a67d...\")\nlocal/path RegistrySpec(path=\"local/path\")\nwww.myregistry.com RegistrySpec(url=\"www.myregistry.com\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.Registry.add","page":"12. API Reference","title":"Pkg.Registry.add","text":"Pkg.Registry.add(registry::RegistrySpec)\n\nAdd new package registries.\n\nThe no-argument Pkg.Registry.add() will install the default registries.\n\nExamples\n\nPkg.Registry.add(\"General\")\nPkg.Registry.add(RegistrySpec(uuid = \"23338594-aafe-5451-b93e-139f81909106\"))\nPkg.Registry.add(RegistrySpec(url = \"https://github.com/JuliaRegistries/General.git\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.rm","page":"12. API Reference","title":"Pkg.Registry.rm","text":"Pkg.Registry.rm(registry::String)\nPkg.Registry.rm(registry::RegistrySpec)\n\nRemove registries.\n\nExamples\n\nPkg.Registry.rm(\"General\")\nPkg.Registry.rm(RegistrySpec(uuid = \"23338594-aafe-5451-b93e-139f81909106\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.update","page":"12. API Reference","title":"Pkg.Registry.update","text":"Pkg.Registry.update()\nPkg.Registry.update(registry::RegistrySpec)\nPkg.Registry.update(registry::Vector{RegistrySpec})\n\nUpdate registries. If no registries are given, update all available registries.\n\nExamples\n\nPkg.Registry.update()\nPkg.Registry.update(\"General\")\nPkg.Registry.update(RegistrySpec(uuid = \"23338594-aafe-5451-b93e-139f81909106\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.status","page":"12. API Reference","title":"Pkg.Registry.status","text":"Pkg.Registry.status()\n\nDisplay information about available registries.\n\nExamples\n\nPkg.Registry.status()\n\n\n\n\n\n","category":"function"},{"location":"api/#Artifacts-Reference","page":"12. API Reference","title":"Artifacts API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"Pkg.Artifacts.create_artifact\nPkg.Artifacts.remove_artifact\nPkg.Artifacts.verify_artifact\nPkg.Artifacts.bind_artifact!\nPkg.Artifacts.unbind_artifact!\nPkg.Artifacts.download_artifact\nPkg.Artifacts.ensure_artifact_installed\nPkg.Artifacts.ensure_all_artifacts_installed\nPkg.Artifacts.archive_artifact","category":"page"},{"location":"api/#Pkg.Artifacts.create_artifact","page":"12. API Reference","title":"Pkg.Artifacts.create_artifact","text":"create_artifact(f::Function)\n\nCreates a new artifact by running f(artifact_path), hashing the result, and moving it to the artifact store (~/.julia/artifacts on a typical installation).  Returns the identifying tree hash of this artifact.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.remove_artifact","page":"12. API Reference","title":"Pkg.Artifacts.remove_artifact","text":"remove_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nRemoves the given artifact (identified by its SHA1 git tree hash) from disk.  Note that if an artifact is installed in multiple depots, it will be removed from all of them.  If an overridden artifact is requested for removal, it will be silently ignored; this method will never attempt to remove an overridden artifact.\n\nIn general, we recommend that you use Pkg.gc() to manage artifact installations and do not use remove_artifact() directly, as it can be difficult to know if an artifact is being used by another package.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.verify_artifact","page":"12. API Reference","title":"Pkg.Artifacts.verify_artifact","text":"verify_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nVerifies that the given artifact (identified by its SHA1 git tree hash) is installed on- disk, and retains its integrity.  If the given artifact is overridden, skips the verification unless honor_overrides is set to true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.bind_artifact!","page":"12. API Reference","title":"Pkg.Artifacts.bind_artifact!","text":"bind_artifact!(artifacts_toml::String, name::String, hash::SHA1;\n               platform::Union{AbstractPlatform,Nothing} = nothing,\n               download_info::Union{Vector{Tuple},Nothing} = nothing,\n               lazy::Bool = false,\n               force::Bool = false)\n\nWrites a mapping of name -> hash within the given (Julia)Artifacts.toml file. If platform is not nothing, this artifact is marked as platform-specific, and will be a multi-mapping.  It is valid to bind multiple artifacts with the same name, but different platforms and hash'es within the same artifacts_toml.  If force is set to true, this will overwrite a pre-existant mapping, otherwise an error is raised.\n\ndownload_info is an optional vector that contains tuples of URLs and a hash.  These URLs will be listed as possible locations where this artifact can be obtained.  If lazy is set to true, even if download information is available, this artifact will not be downloaded until it is accessed via the artifact\"name\" syntax, or ensure_artifact_installed() is called upon it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.unbind_artifact!","page":"12. API Reference","title":"Pkg.Artifacts.unbind_artifact!","text":"unbind_artifact!(artifacts_toml::String, name::String; platform = nothing)\n\nUnbind the given name from an (Julia)Artifacts.toml file. Silently fails if no such binding exists within the file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.download_artifact","page":"12. API Reference","title":"Pkg.Artifacts.download_artifact","text":"download_artifact(tree_hash::SHA1, tarball_url::String, tarball_hash::String;\n                  verbose::Bool = false, io::IO=stderr)\n\nDownload/install an artifact into the artifact store.  Returns true on success, returns an error object on failure.\n\ncompat: Julia 1.8\nAs of Julia 1.8 this function returns the error object rather than false when failure occurs\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.ensure_artifact_installed","page":"12. API Reference","title":"Pkg.Artifacts.ensure_artifact_installed","text":"ensure_artifact_installed(name::String, artifacts_toml::String;\n                          platform::AbstractPlatform = HostPlatform(),\n                          pkg_uuid::Union{Base.UUID,Nothing}=nothing,\n                          verbose::Bool = false,\n                          quiet_download::Bool = false,\n                          io::IO=stderr)\n\nEnsures an artifact is installed, downloading it via the download information stored in artifacts_toml if necessary.  Throws an error if unable to install.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.ensure_all_artifacts_installed","page":"12. API Reference","title":"Pkg.Artifacts.ensure_all_artifacts_installed","text":"ensure_all_artifacts_installed(artifacts_toml::String;\n                               platform = HostPlatform(),\n                               pkg_uuid = nothing,\n                               include_lazy = false,\n                               verbose = false,\n                               quiet_download = false,\n                               io::IO=stderr)\n\nInstalls all non-lazy artifacts from a given (Julia)Artifacts.toml file. package_uuid must be provided to properly support overrides from Overrides.toml entries in depots.\n\nIf include_lazy is set to true, then lazy packages will be installed as well.\n\nThis function is deprecated and should be replaced with the following snippet:\n\nartifacts = select_downloadable_artifacts(artifacts_toml; platform, include_lazy)\nfor name in keys(artifacts)\n    ensure_artifact_installed(name, artifacts[name], artifacts_toml; platform=platform)\nend\n\nwarning: Warning\nThis function is deprecated in Julia 1.6 and will be removed in a future version. Use select_downloadable_artifacts() and ensure_artifact_installed() instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.archive_artifact","page":"12. API Reference","title":"Pkg.Artifacts.archive_artifact","text":"archive_artifact(hash::SHA1, tarball_path::String; honor_overrides::Bool=false)\n\nArchive an artifact into a tarball stored at tarball_path, returns the SHA256 of the resultant tarball as a hexadecimal string. Throws an error if the artifact does not exist.  If the artifact is overridden, throws an error unless honor_overrides is set.\n\n\n\n\n\n","category":"function"},{"location":"managing-packages/#Managing-Packages","page":"3. 管理包","title":"3. 管理包","text":"","category":"section"},{"location":"managing-packages/#添加包","page":"3. 管理包","title":"添加包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"有两种添加包的方法，使用 add 或 dev 命令。最常用的是 add，首先描述它的用法。","category":"page"},{"location":"managing-packages/#添加已注册包","page":"3. 管理包","title":"添加已注册包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"在Pkg REPL中，可以使用 add 命令后跟包名来添加包，例如：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> add JSON\n  Installing known registries into `~/`\n   Resolving package versions...\n   Installed Parsers ─ v2.4.0\n   Installed JSON ──── v0.21.3\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [682c06a0] + JSON v0.21.3\n    Updating `~/environments/v1.9/Manifest.toml`\n  [682c06a0] + JSON v0.21.3\n  [69de0a69] + Parsers v2.4.0\n  [ade2ca70] + Dates\n  [a63ad114] + Mmap\n  [de0858da] + Printf\n  [4ec0a83e] + Unicode\nPrecompiling environment...\n  2 dependencies successfully precompiled in 2 seconds","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"这里我们将包 Example 添加到当前环境（这是默认 @v1.8 环境）。在此示例中，我们使用全新的 Julia 安装，这是我们第一次使用 Pkg 添加包。默认情况下，Pkg 安装 General 注册表并使用此注册表查找请求包含在当前环境中的包。状态更新在左侧显示包 UUID 的简短形式，然后是包名称和版本。最后，新安装的包被“预编译”。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"可以以 pkg> add A B C 形式在一个命令中添加多个包。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"status 输出您自己添加的包，在本例中为 JSON：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> st\n    Status `~/.julia/environments/v1.8/Project.toml`\n  [682c06a0] JSON v0.21.3","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"status -m 显示环境中的所有包，包括递归依赖项：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> st -m\nStatus `~/environments/v1.9/Manifest.toml`\n  [682c06a0] JSON v0.21.3\n  [69de0a69] Parsers v2.4.0\n  [ade2ca70] Dates\n  [a63ad114] Mmap\n  [de0858da] Printf\n  [4ec0a83e] Unicode","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"由于标准库（例如 Dates）随 Julia 一起提供，因此它们没有版本。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"将包添加到项目后，可以在 Julia 中加载它：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"julia> using JSON\n\njulia> JSON.json(Dict(\"foo\" => [1, \"bar\"])) |> print\n{\"foo\":[1,\"bar\"]}","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"note: Note\n只能加载已被 add 添加的包（即在 Pkg REPL 中使用 st 时显示的包）。仅作为依赖项引入的包（例如上面的 Parsers 包）无法加载。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"可以通过在包名称后面附加一个 @ 及版本号来安装包的特定版本：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> add JSON@0.21.1\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n⌃ [682c06a0] + JSON v0.21.1\n    Updating `~/environments/v1.9/Manifest.toml`\n⌃ [682c06a0] + JSON v0.21.1\n⌅ [69de0a69] + Parsers v1.1.2\n  [ade2ca70] + Dates\n  [a63ad114] + Mmap\n  [de0858da] + Printf\n  [4ec0a83e] + Unicode\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated -m`","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"如上所示，当软件包安装的不是其最新版本时，Pkg 会提供一些信息。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"如果没有为版本提供所有三个数字，例如0.21，则将安装最后注册的版本0.21.x。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"如果 Example 的某个分支（或某个提交）有一个尚未包含在注册版本中的补丁程序，我们可以通过将 #branchname（或 #commitSHA1）附加到包名称后来显式跟踪该分支（或提交）：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> add Example#master\n     Cloning git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n    Updating `~/environments/v1.9/Manifest.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"现在状态输出显示我们正在跟踪 Example 的 master 分支. 更新包时，会从该分支中​​提取更新。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"note: Note\n如果我们指定一个提交 id 而不是分支名称，例如 add Example#025cf7e，那么我们将有效地将包“pin”到该提交。这是因为提交 id 总是指向同一个东西，而不像一个分支，它可能会被更新。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"要回到跟踪 Example 的注册版本，请使用命令 free：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> free Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3\n    Updating `~/environments/v1.9/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3","category":"page"},{"location":"managing-packages/#添加未注册包","page":"3. 管理包","title":"添加未注册包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"如果一个包不在注册表上，它可以通过指定 Git 仓库的 URL 来添加：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> add https://github.com/fredrikekre/ImportMacros.jl\n     Cloning git-repo `https://github.com/fredrikekre/ImportMacros.jl`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`\n    Updating `~/environments/v1.9/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"未注册包的依赖(这里是 MacroTools)也会被安装。对于未注册的包，我们可以使用 # 给出一个分支名称（或提交的 SHA1）来跟踪 ，就像已注册包一样。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"如果要使用基于 SSH 的 git 协议添加包，则必须使用引号，因为 URL 包含 @. 例如：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> add \"git@github.com:fredrikekre/ImportMacros.jl.git\"\n    Cloning git-repo `git@github.com:fredrikekre/ImportMacros.jl.git`\n   Updating registry at `~/.julia/registries/General`\n  Resolving package versions...\nUpdating `~/.julia/environments/v1/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`\nUpdating `~/.julia/environments/v1/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`","category":"page"},{"location":"managing-packages/#从仓库的子目录中添加包","page":"3. 管理包","title":"从仓库的子目录中添加包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"如果要通过 URL 添加的包不在存储库的根目录中，则需要使用 :。例如，要添加SnoopCompile仓库中的 SnoopCompileCore 包 ：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"pkg> add https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore\n    Cloning git-repo `https://github.com/timholy/SnoopCompile.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n  [9e88b42a] + Serialization","category":"page"},{"location":"managing-packages/#添加本地包","page":"3. 管理包","title":"添加本地包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"通过传递给 add 一个git仓库的本地路径来代替git仓库的 URL，它能像 URL 一样工作。将跟踪本地存储库（在某个分支），并在更新包时从该本地存储库中提取更新。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"warning: Warning\n请注意，通过 add 跟踪包的方式不同于 develop（将在下一节中描述）。在本地 git 存储库上使用 add 时，在加载该包时不会立即反映对本地包存储库中文件的更改。必须提交更改并更新软件包才能引入更改。在大多数情况下，您希望在本地路径上使用 develop  ，**而非add`**。","category":"page"},{"location":"managing-packages/#developing","page":"3. 管理包","title":"开发中的包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"通过仅使用 add，您的环境始终具有“可重现状态”，换句话说，只要使用的仓库和注册表仍然可以访问，就可以检索环境中所有依赖项的确切状态。这样做的好处是您可以将您的环境 (Project.toml 和 Manifest.toml) 发送给其他人，并且他们可以 Pkg.instantiate 此环境，来重现您本地环境的相同状态。然而，当你在开发一个包时，在某个路径上加载它们的当前状态会更方便。因此，存在 dev 命令。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"让我们尝试 dev 一个已注册包：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> dev Example\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"dev 命令将包的完整克隆 fetch 到 ~/.julia/dev/（可以通过设置环境变量 JULIA_PKG_DEVDIR 来更改路径，默认为 joinpath(DEPOT_PATH[1],\"dev\")）。现在，当导入 Example 时， julia 将从 ~/.julia/dev/Example 中导入它，对该路径中的文件所做的任何本地更改都会反映在加载的代码中。当使用 add 时，我们说跟踪了包存储库；在这里我们说跟踪了路径本身。请注意，包管理器永远不会触及跟踪路径中的任何文件，因此，拉取更新、更改分支等操作都由您自己决定。如果我们尝试 dev 已经存在于 ~/.julia/dev/ 的包上的某个分支，包管理器将简单地重新使用现有路径。如果在本地路径上使用 dev，该包的路径将被记录并在加载该包时使用。路径将相对于项目文件进行记录，除非它以绝对路径的形式给出。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"让我们尝试修改文件 ~/.julia/dev/Example/src/Example.jl 并添加一个简单的函数：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"plusone(x::Int) = x + 1","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"现在我们可以回到 Julia REPL 加载包并运行新函数：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"julia> import Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n\njulia> Example.plusone(1)\n2","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"warning: Warning\n每个 Julia 会话只能加载一次包。如果您已在当前 Julia 会话中运行过 import Example，则必须重新启动 Julia 才能看到对示例的更改。 Revise.jl可以使这个过程变得更轻松，但是设置它超出了本指南的范围。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"要停止跟踪路径并再次使用已注册版本，请使用 free：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> free Example\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"应该指出的是，通过使用 dev ,您的项目现在本质上是有状态的。它的状态取决于路径中文件的当前内容，并且在不知道跟踪路径中所有包的确切内容的情况下，manifest 不能被其他人“实例化”。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"请注意，如果您向跟踪本地路径的包添加依赖项，则 Manifest（包含整个依赖关系图）将与实际依赖关系图不同步。这意味着包将无法加载该依赖项，因为它没有记录在 Manifest 中。要同步 Manifest，请使用 REPL 命令 resolve。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"除了绝对路径外，add 和 dev 还可以接受包的相对路径。在这种情况下，将存储从活动项目到包的相对路径。当被跟踪依赖项的相对位置比它们的绝对位置更重要时，这种方法很有用。例如，跟踪的依赖项可以存储在活动项目目录中。整个目录可以移动并且 Pkg 仍然能够找到依赖项，因为它们对于活动项目的相对路径被保留，即使它们的绝对路径已经发生改变。","category":"page"},{"location":"managing-packages/#移除包","page":"3. 管理包","title":"移除包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"可以使用 pkg> rm Package 从当前项目中移除包。这只会移除项目中存在的包；要移除仅作为依赖项存在的包，请使用 pkg> rm --manifest DepPackage。请注意，这将移除（递归地）DepPackage 依赖的所有包。","category":"page"},{"location":"managing-packages/#updating","page":"3. 管理包","title":"更新包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"发布新版本的软件包时，最好进行更新。只需调用 up 命令，尝试将项目的所有依赖更新到最新的兼容版本。有时这不是你想要的。您可以通过将依赖项的子集作为参数提供给 up 来指定要升级的包，例如：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> up Example","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"这将只允许 Example 进行升级。如果您还想允许 Example 的依赖项升级（项目中的包除外），您可以传递 --preserve=direct 参数。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> up --preserve=direct Example","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"如果您还想允许项目中的 Example 的依赖项进行升级，您可以使用 --preserve=none：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> up --preserve=none Example","category":"page"},{"location":"managing-packages/#固定包","page":"3. 管理包","title":"固定包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"固定包永远不会更新。可以使用 pin 来固定一个包，例如：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> pin Example\n Resolving package versions...\n  Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"请注意 ⚲ 符号显示包已经被固定。要移除固定使用 free 命令：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> free Example\n  Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3","category":"page"},{"location":"managing-packages/#测试包","page":"3. 管理包","title":"测试包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"可以使用 test 命令运行包的测试： The tests for a package can be run using test command:","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> test Example\n...\n   Testing Example\n   Testing Example tests passed","category":"page"},{"location":"managing-packages/#构建包","page":"3. 管理包","title":"构建包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"首次安装包时，包的构建步骤会自动运行。构建过程的输出被定向到一个文件。要显式运行包的构建步骤，请使用 build 命令：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> build IJulia\n    Building Conda ─→ `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/6e47d11ea2776bc5627421d59cdcc1296c058071/build.log`\n    Building IJulia → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log`\n\njulia> print(read(joinpath(homedir(), \".julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log\"), String))\n[ Info: Installing Julia kernelspec in /home/kc/.local/share/jupyter/kernels/julia-1.8","category":"page"},{"location":"managing-packages/#conflicts","page":"3. 管理包","title":"解释和解决版本冲突","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"一个环境由一组相互兼容的包组成。有时，您会发现自己要同时使用的两个软件包对环境的要求互相不兼容。在这种情况下，您会收到“Unsatisfiable requirements”错误：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"using Pkg\ninclude(joinpath(pkgdir(Pkg), \"test\", \"resolve_utils.jl\"))\nusing .ResolveUtils\ndeps_data = Any[[\"A\", v\"1.0.0\", \"C\", v\"0.2\"],\n                [\"B\", v\"1.0.0\", \"D\", v\"0.1\"],\n                [\"C\", v\"0.1.0\", \"D\", v\"0.1\"],\n                [\"C\", v\"0.1.1\", \"D\", v\"0.1\"],\n                [\"C\", v\"0.2.0\", \"D\", v\"0.2\"],\n                [\"D\", v\"0.1.0\"],\n                [\"D\", v\"0.2.0\"],\n                [\"D\", v\"0.2.1\"]]\nreqs_data = Any[[\"A\", \"*\"],\n                [\"B\", \"*\"]]","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"print(\"pkg> add A\\n\", try resolve_tst(deps_data, reqs_data) catch e sprint(showerror, e) end)   # hide","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"此消息意味着一个名为 D 的包有版本冲突，即使您从未直接 add 过 D。如果您尝试使用的其他软件包也需要 D，同样会出现这种错误。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"note: Note\n在处理这些冲突时，首先要考虑项目越大，发生这种情况的可能性就越大。强烈建议为给定任务使用专用项目，并且在遇到这些问题时删除未使用的依赖项。例如，一个常见的陷阱是，在您的默认环境（即 (@1.8)）中包含有多个包，并将其用作您使用 julia 执行的所有任务的环境。最好为您正在处理的任务创建一个专用项目，并将依赖关系保持在最低限度。要了解更多信息，请参阅 使用“环境”","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"错误消息包含很多关键信息。分段解释可能最容易：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"Unsatisfiable requirements detected for package D [756980fe]:\n D [756980fe] log:\n ├─possible versions are: [0.1.0, 0.2.0-0.2.1] or uninstalled","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"表示 D 具有三个发布版本，v0.1.0、v0.2.0和v0.2.1。您还可以选择根本不安装它。这些选项中的每一个都可能对可以安装的其他软件包集具有不同的含义。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"更重要的是，请注意笔画字符（垂直和水平线）及其缩进。这些字符组合在一起将消息连接到特定的包。例如，右边的笔划 ├─ 表示其右边的消息 (possible versions...) 连接到其垂直笔划指向的包(D) 。同样的规则适用于下一行：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":" ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"这里的垂直笔划也对齐在 D 下方，因此该消息是引用到 D 的。具体来说，还有另外的包 B 依赖于 D 的 v0.1.0版本. 请注意，这不是 D 的最新版本。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"接下来是一些关于 B 的信息：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":" │ └─B [f4259836] log:\n │   ├─possible versions are: 1.0.0 or uninstalled\n │   └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"第一行下面的两行有一个与 B 对齐的垂直笔划，因此它们提供了关于 B 的信息。他们告诉你 B 只有一个版本 v1.0.0。您没有指定过 B 的特定版本(restricted to versions * 表示任何版本都可以)，但是 explicit requirement 表明您要求B成为环境的一部分，例如曾执行过 pkg> add B。您之前可能已经添加过 B 了，但这里对特定版本的依赖仍然有效。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"冲突变得清晰了：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"└─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"同样，垂直笔划与 D 对齐：这意味着 D 也被 C 包依赖，C 依赖 D 的 v0.2.0 版本。这和 B 依赖 D 的 v0.1.0 版本是冲突的。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"但是等等，你可能会问，C 是什么，我为什么需要它？接下来的几行介绍了这个问题：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"   └─C [c99a7cb2] log:\n     ├─possible versions are: [0.1.0-0.1.1, 0.2.0] or uninstalled\n     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"这些提供了有关 C 的更多信息，表明它有 3 个已发布版本：v0.1.0、v0.1.1和v0.2.0。此外，C 是另一个包 A 所必需的。确实，A 要求 v0.2.0版本的 C。 A 的起源在接下来的几行中揭示：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"       └─A [29c70717] log:\n         ├─possible versions are: 1.0.0 or uninstalled\n         └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"所以我们可以看到 A 是 explicitly required 的, 并且在此示例中，我们尝试将它 add 到我们的环境中。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"总之，我们明确要求使用 A 和 B，但这里显示了一个 D 的冲突，原因是 B 和 C 依赖的 D 的版本冲突。 尽管 C 不是我们明确要求的，但 A 是。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"要修复此类错误，您有多种选择：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"尝试更新包。这些软件包的开发人员可能最近发布了相互兼容的新版本。\n从您的环境中删除 A 或删除 B。也许 B 是你以前工作的时候遗留下来的，你已经不再需要它了。如果您同时不需要 A和B，这是解决问题的最简单方法。\n尝试报告您的冲突。在这种情况下，我们能够推断出 B 依赖 D 的过时版本。 因此，您可以在 B.jl 的开发存储库中报告问题，要求更新 D 版本。\n尝试自己解决问题。一旦您了解 Project.toml 文件以及它们如何声明其兼容性要求，这将变得更容易。我们将在修复冲突中回到这个例子。","category":"page"},{"location":"managing-packages/#垃圾收集旧的、未使用的包","page":"3. 管理包","title":"垃圾收集旧的、未使用的包","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"随着包的更新和项目的删除，曾经使用过的已安装包的版本和组件将不可避免地变旧，并且不会再被任何现有项目使用。Pkg 保留所有项目的使用日志，以便它可以查看日志并准确查看哪些项目仍然存在，以及这些项目使用了哪些包/artifacts。如果包或 artifacts 未被任何项目标记为正在使用，则会将其添加到孤立包列表中。处于孤立列表中 30 天未再次使用的包和 artifacts 会在下一次垃圾回收时从系统中删除。这个时间可以通过 Pkg.gc() 的 collect_delay 关键字参数来配置。值 0 将导致立即收集当前未使用的任何内容，完全跳过孤儿列表；如果您的磁盘空间不足，并且想清理尽可能多的未使用的包和 artifacts，您可能想尝试此参数，但如果您再次需要这些版本，则必须重新下载它们。要使用默认参数运行典型的垃圾收集，只需使用 pkg> REPL中的 gc 命令：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"(@v1.8) pkg> gc\n    Active manifests at:\n        `~/BinaryProvider/Manifest.toml`\n        ...\n        `~/Compat.jl/Manifest.toml`\n    Active artifacts:\n        `~/src/MyProject/Artifacts.toml`\n\n    Deleted ~/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB\n    Deleted ~/.julia/packages/Cassette/BXVB: 795.557 KiB\n   ...\n   Deleted `~/.julia/artifacts/e44cdf2579a92ad5cbacd1cddb7414c8b9d2e24e` (152.253 KiB)\n   Deleted `~/.julia/artifacts/f2df5266567842bbb8a06acca56bcabf813cd73f` (21.536 MiB)\n\n   Deleted 36 package installations (113.205 MiB)\n   Deleted 15 artifact installations (20.759 GiB)","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"请注意，只有 ~/.julia/packages 中的包被删除。","category":"page"},{"location":"managing-packages/#离线模式","page":"3. 管理包","title":"离线模式","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"在离线模式下，Pkg 尝试在不连接互联网的情况下尽可能做的更多。例如，当添加一个包时，Pkg 只考虑版本解析中已经下载的版本。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"要在离线模式下工作，请使用 import Pkg; Pkg.offline(true) 或将环境变量 JULIA_PKG_OFFLINE 设置为 \"true\"。","category":"page"},{"location":"managing-packages/#Pkg-客户端/服务器","page":"3. 管理包","title":"Pkg 客户端/服务器","text":"","category":"section"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"当你添加一个新的已注册包时，通常会发生三件事：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"更新注册表，\n下载包的源代码，\n如果不可用，请下载软件包所需的 artifacts。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"General 注册表和其中的大多数包都是在 GitHub 上开发的，而 artifacts 数据则托管在各种平台上。当与 GitHub 和 AWS S3 的网络连接不稳定时，安装或更新包的体验通常不是很好。幸运的是，pkg 客户端/服务器功能在以下方面改善了体验：","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"如果设置，pkg 客户端将首先尝试从 pkg 服务器下载数据，\n如果失败，则返回到从原始来源（例如，GitHub）下载。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"从 Julia 1.5 开始，https://pkg.julialang.org 由 JuliaLang 组织提供并作为默认 pkg 服务器。在大多数情况下，这应该是透明的，但用户仍然可以通过环境变量 JULIA_PKG_SERVER 设置/取消设置上游的 pkg 服务器。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"# manually set it to some pkg server\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"pkg.julialang.org\"\n\"pkg.julialang.org\"\n\n# unset to always download data from original sources\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"\"\n\"\"","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"澄清一下，Pkg 服务器未提供某些来源。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"通过 git 获取包/注册表\n]add https://github.com/JuliaLang/Example.jl.git\n]add Example#v0.5.3（请注意，这与 ]add Example@0.5.3 不同）\n]registry add https://github.com/JuliaRegistries/General.git，包括 Julia 在 1.4 之前安装的注册表。\n没有下载信息的artifacts\nTestImages","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"note: Note\n如果您通过 pkg 服务器安装了新的注册表，那么旧 Julia 版本不可能更新注册表，因为 1.4 之前的 Julia 不知道如何获取新数据。因此，对于经常在多个 Julia 版本之间切换的用户，建议仍然使用 git 控制注册表。","category":"page"},{"location":"managing-packages/","page":"3. 管理包","title":"3. 管理包","text":"pkg server 的部署请参考 PkgServer.jl。","category":"page"},{"location":"environments/#Working-with-Environments","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"","category":"section"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"下面讨论 Pkg 与环境的交互。有关环境在代码加载中扮演的角色的更多信息，包括可以从中加载代码的环境的“栈”，请参阅Julia 手册中的此部分。","category":"page"},{"location":"environments/#创建自己的环境","page":"4. 使用“环境”","title":"创建自己的环境","text":"","category":"section"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"到目前为止，我们已经将包添加到默认环境中 ~/.julia/environments/v1.8。然而，创建另外的独立项目很容易。这种方法的好处是允许您在代码旁边创建 Project.toml 及 Manifest.toml 文件，并添加进版本控制（例如 git）中。需要指出的是，当两个项目使用相同版本的同一个包时，这个包的内容只保存一份。为新项目创建一个目录，然后激活该目录以使其成为“活动项目”，操作如下：","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"(@v1.8) pkg> activate MyProject\nActivating new environment at `~/MyProject/Project.toml`\n\n(MyProject) pkg> st\n    Status `~/MyProject/Project.toml` (empty project)","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"请注意，激活新项目时，REPL 提示会发生变化。在添加包之前，此环境中没有文件，甚至可能不会创建环境目录：","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"julia> isdir(\"MyProject\")\nfalse\n\n(MyProject) pkg> add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/MyProject/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~~/MyProject/Manifest.toml`\n  [7876af07] + Example v0.5.3\nPrecompiling environment...\n  1 dependency successfully precompiled in 2 seconds\n\njulia> readdir(\"MyProject\")\n2-element Vector{String}:\n \"Manifest.toml\"\n \"Project.toml\"\n\njulia> print(read(joinpath(\"MyProject\", \"Project.toml\"), String))\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\njulia> print(read(joinpath(\"MyProject\", \"Manifest.toml\"), String))\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.8.2\"\nmanifest_format = \"2.0\"\nproject_hash = \"2ca1c6c58cb30e79e021fb54e5626c96d05d5fdc\"\n\n[[deps.Example]]\ngit-tree-sha1 = \"46e44e869b4d90b96bd8ed1fdcf32244fddfb6cc\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"0.5.3\"","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"新环境与我们之前使用的环境完全不同。有关更详细的说明，请参阅 Project.toml 和 Manifest.toml。","category":"page"},{"location":"environments/#使用别人的项目","page":"4. 使用“环境”","title":"使用别人的项目","text":"","category":"section"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"只需使用 git clone 克隆别人的项目， 然后 cd 到项目目录并调用：","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"shell> git clone https://github.com/JuliaLang/Example.jl.git\nCloning into 'Example.jl'...\n...\n\n(@v1.8) pkg> activate Example.jl\nActivating project at `~/Example.jl`\n\n(Example) pkg> instantiate\n  No Changes to `~/Example.jl/Project.toml`\n  No Changes to `~/Example.jl/Manifest.toml`","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"如果项目包含 manifest，这将以该 manifest 给出的相同状态安装包。否则，它将解析与项目兼容的最新版本的依赖项。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"请注意，activate 本身不会安装缺少的依赖项。如果您只有一个 Project.toml 文件， 则 Manifest.toml 必须通过“解析”环境来生成，任何丢失的包都必须安装并预编译。instantiate 命令为你做了这些工作。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"如果您已经有一个已解析的 Manifest.toml，那您仍然需要确保所有软件包及其正确版本都已安装。 instantiate 再次为您执行这些操作。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"简而言之，instantiate 确保环境已经准备好可以使用。如果什么也不用做，那么 instantiate 什么也不做。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"note: Note\n您可以使用 --project=<path> 参数在启动时指定项目，替代在 Julia 中使用 activate。例如，要使用当前目录中的环境从命令行运行脚本，您可以运行 $ julia --project=. myscript.jl","category":"page"},{"location":"environments/#临时环境","page":"4. 使用“环境”","title":"临时环境","text":"","category":"section"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"临时环境可以轻松地从空白环境开始以测试一个包或一组包，并让 Pkg 在您测试完后自动删除环境。例如，在编写错误报告时，您可能希望在一个“干净”环境中测试您的最小复现示例，以保证它确实是可复现的。您可能还需要一个临时空间来试用一个新包，或者一个沙箱来解决几个不兼容的包之间的版本冲突。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"(@v1.8) pkg> activate --temp # requires Julia 1.5 or later\n  Activating new environment at `/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n\n(jl_a31egx) pkg> add Example\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Manifest.toml`\n  [7876af07] + Example v0.5.3","category":"page"},{"location":"environments/#共享环境","page":"4. 使用“环境”","title":"共享环境","text":"","category":"section"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"“共享”环境是存在于 ~/.julia/environments 的简单环境，因此，默认的 v1.8 环境是共享环境：","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"(@v1.8) pkg> st\nStatus `~/.julia/environments/v1.8/Project.toml`","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"可以使用 activate 命令的 --shared 参数激活共享环境 ：","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"(@v1.8) pkg> activate --shared mysharedenv\n  Activating project at `~/.julia/environments/mysharedenv`\n\n(@mysharedenv) pkg>","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"共享环境在 Pkg REPL 提示符中的名称前有一个 @。","category":"page"},{"location":"environments/#环境预编译","page":"4. 使用“环境”","title":"环境预编译","text":"","category":"section"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"在导入包之前，Julia 会将源代码“预编译”到磁盘上更高效的中间缓存中。如果未导入的包是新的或自上次缓存以来已发生更改，则可以通过“代码加载”触发此预编译。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"julia> using Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"或者使用 Pkg 的预编译选项，它可以并行预编译整个环境或给定的依赖项，这比上面的代码加载方式快得多。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"(@v1.8) pkg> precompile\nPrecompiling environment...\n  23 dependencies successfully precompiled in 36 seconds","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"然而，由于 Pkg 的自动预编译机制，以上两种方式通常是不需要的。","category":"page"},{"location":"environments/#自动预编译","page":"4. 使用“环境”","title":"自动预编译","text":"","category":"section"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"默认情况下，任何添加到项目或在 Pkg 操作中更新的包以及它的依赖项都将自动预编译。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"(@v1.8) pkg> add Images\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.9/Project.toml`\n  [916415d5] + Images v0.25.2\n    Updating `~/.julia/environments/v1.9/Manifest.toml`\n    ...\nPrecompiling environment...\n  Progress [===================>                     ]  45/97\n  ✓ NaNMath\n  ✓ IntervalSets\n  ◐ CoordinateTransformations\n  ◑ ArnoldiMethod\n  ◑ IntegralArrays\n  ◒ RegionTrees\n  ◐ ChangesOfVariables\n  ◓ PaddedViews","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"develop 命令是个例外，它既不构建也不预编译包。何时预编译由用户决定。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"如果在自动预编译期间给定的包版本出错，Pkg 会记住它，下面的自动尝试都会跳过该包并发出简短的警告。手动预编译可用于强制重试这些包，因为 pkg> precompile 将始终重试所有包。","category":"page"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"要禁用自动预编译，请设置 ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0.","category":"page"},{"location":"environments/#预编译已加载包的新版本","page":"4. 使用“环境”","title":"预编译已加载包的新版本","text":"","category":"section"},{"location":"environments/","page":"4. 使用“环境”","title":"4. 使用“环境”","text":"如果会话中已经加载了已更新的包，则预编译过程将继续并预编译新版本以及任何依赖它的包，但需注意该包在会话重新启动之前无法使用。","category":"page"},{"location":"creating-packages/#**5.**-创建包","page":"5. 创建包","title":"5. 创建包","text":"","category":"section"},{"location":"creating-packages/#为包生成文件","page":"5. 创建包","title":"为包生成文件","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"note: Note\nPkgTemplates包提供了一种简单、可重复和可定制的方式来为新包生成文件。它还可以生成文档、CI 等所需的文件。我们建议您使用 PkgTemplates 来创建新包，而不是使用下面描述的最小 pkg> generate 功能。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"要为新包生成最少的文件，请使用 pkg> generate.","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"(@v1.8) pkg> generate HelloWorld","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"这将创建一个包含以下文件的新项目 HelloWorld（使用外部 tree command 命令可视化）：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"julia> cd(\"HelloWorld\")\n\nshell> tree .\n.\n├── Project.toml\n└── src\n    └── HelloWorld.jl\n\n1 directory, 2 files","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"Project.toml 文件包含包名、唯一的 UUID、版本、作者和潜在的依赖项：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"name = \"HelloWorld\"\nuuid = \"b4cd1eb8-1e24-11e8-3319-93036a3eb9f3\"\nversion = \"0.1.0\"\nauthors = [\"Some One <someone@email.com>\"]\n\n[deps]","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"src/HelloWorld.jl 的内容是:","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"module HelloWorld\n\ngreet() = print(\"Hello World!\")\n\nend # module","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"我们现在可以激活项目并加载包：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"pkg> activate .\n\njulia> import HelloWorld\n\njulia> HelloWorld.greet()\nHello World!","category":"page"},{"location":"creating-packages/#将依赖项添加到项目中","page":"5. 创建包","title":"将依赖项添加到项目中","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"假设我们要在我们的项目中使用标准库包 Random 及已注册包 JSON。我们只 add 这些包（注意提示符现在如何显示新生成的项目的名称，因为我们已经 activated 了它）：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"(HelloWorld) pkg> add Random JSON\n   Resolving package versions...\n    Updating `~/HelloWorld/Project.toml`\n  [682c06a0] + JSON v0.21.3\n  [9a3f8284] + Random\n    Updating `~/HelloWorld/Manifest.toml`\n  [682c06a0] + JSON v0.21.3\n  [69de0a69] + Parsers v2.4.0\n  [ade2ca70] + Dates\n ...","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"Random 和 JSON都被添加到项目的 Project.toml 文件中，并且生成的依赖项被添加到 Manifest.toml 文件中。解析器已经尽可能安装了每个包的高版本，同时仍然尊重每个包对其依赖项强制执行的兼容性。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"现在可以在我们的项目中使用 Random 和 JSON。修改 src/HelloWorld.jl 为：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"module HelloWorld\n\nimport Random\nimport JSON\n\ngreet() = print(\"Hello World!\")\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"重新加载包，使用 Random 的新函数 greet_alien 可以被调用：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"julia> HelloWorld.greet_alien()\nHello aT157rHV","category":"page"},{"location":"creating-packages/#向包中添加构建步骤","page":"5. 创建包","title":"向包中添加构建步骤","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"构建步骤在首次安装包或使用 build 时执行，通过执行文件 deps/build.jl 构建一个包。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"julia> print(read(\"deps/build.jl\", String))\nprintln(\"I am being built...\")\n\n(HelloWorld) pkg> build\n  Building HelloWorld → `deps/build.log`\n Resolving package versions...\n\njulia> print(read(\"deps/build.log\", String))\nI am being built...","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"如果构建步骤失败，则将构建步骤的输出打印到控制台","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"julia> print(read(\"deps/build.jl\", String))\nerror(\"Ooops\")\n\n(HelloWorld) pkg> build\n    Building HelloWorld → `~/HelloWorld/deps/build.log`\nERROR: Error building `HelloWorld`:\nERROR: LoadError: Ooops\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] top-level scope\n   @ ~/HelloWorld/deps/build.jl:1\n [3] include(fname::String)\n   @ Base.MainInclude ./client.jl:476\n [4] top-level scope\n   @ none:5\nin expression starting at /home/kc/HelloWorld/deps/build.jl:1","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"warning: Warning\n构建步骤通常不应在包目录中创建或修改任何文件。如果您需要存储构建步骤中的一些文件，请使用 Scratch.jl 包。","category":"page"},{"location":"creating-packages/#向包中添加测试","page":"5. 创建包","title":"向包中添加测试","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"当一个包被测试时，文件 test/runtests.jl 被执行：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"julia> print(read(\"test/runtests.jl\", String))\nprintln(\"Testing...\")\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\nTesting...\n   Testing HelloWorld tests passed","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"测试在一个新的 Julia 进程中运行，其中包本身以及任何特定于测试的依赖项都可用，见下文。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"warning: Warning\n测试通常不应在包目录中创建或修改任何文件。如果您需要存储构建步骤中的一些文件，请使用Scratch.jl包。","category":"page"},{"location":"creating-packages/#特定于测试的依赖项","page":"5. 创建包","title":"特定于测试的依赖项","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"有两种方法可以添加特定于测试的依赖项（依赖项不是包的依赖项，但在测试包时仍然可以加载）。","category":"page"},{"location":"creating-packages/#基于-target-测试特定依赖项","page":"5. 创建包","title":"基于 target 测试特定依赖项","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"使用此方法添加特定于测试的依赖项，将包添加到 [extras] 节下并添加到测试目标，例如要添加 Markdown 和 Test 作为测试依赖项，添加以下内容到Project.toml文件。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"[extras]\nMarkdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Markdown\", \"Test\"]","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"此例中除了 test 之外，没有其他“targets” 。","category":"page"},{"location":"creating-packages/#test/Project.toml-文件测试特定依赖项","page":"5. 创建包","title":"test/Project.toml 文件测试特定依赖项","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"note: Note\nProject.toml，test/Project.toml 以及它们对应的 Manifest.toml 之间的确切交互尚未完全确定，并且在未来的版本中可能会发生变化。因此，所有 Julia 1.X 版本都支持添加特定于测试的依赖项的旧方法，将在下一节中介绍。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"由于是由 test/Project.toml 给出的，因此，在运行测试时，这将会成为活动项目，并且只能使用依赖于 test/Project.toml 的项目。请注意，Pkg 将隐式添加测试包本身。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"note: Note\n如果 test/Project.toml 不存在, Pkg 将使用基于target测试特定依赖项。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"要添加特定于测试的依赖项（即仅在测试时可用的依赖项），只需将此依赖项添加到 test/Project.toml 项目中就足够了。可以通过从 Pkg REPL 中激活此环境，然后像平时一样使用 add 添加依赖。让我们添加 Test 标准库作为测试依赖项：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"(HelloWorld) pkg> activate ./test\n[ Info: activating environment at `~/HelloWorld/test/Project.toml`.\n\n(test) pkg> add Test\n Resolving package versions...\n  Updating `~/HelloWorld/test/Project.toml`\n  [8dfed614] + Test\n  Updating `~/HelloWorld/test/Manifest.toml`\n  [...]","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"现在可以在测试脚本中使用 Test ，可以看到它在测试时被安装：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"julia> print(read(\"test/runtests.jl\", String))\nusing Test\n@test 1 == 1\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n  [8dfed614] + Test\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n   Testing HelloWorld tests passed```","category":"page"},{"location":"creating-packages/#依赖的兼容性","page":"5. 创建包","title":"依赖的兼容性","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"一般来说，每个依赖项都应该有一个兼容性约束。这是一个重要的话题，所以有一个单独的章节：兼容性。","category":"page"},{"location":"creating-packages/#Package-naming-guidelines","page":"5. 创建包","title":"包命名准则","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"对于大多数 Julia 用户来说，包名应该是切合实际的，即使对于那些不是领域专家的人来说也是如此。以下指南适用于 General 注册表，但也可能对其他包注册表有用。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"由于 General 注册表属于整个社区，所以当你发布包时，人们可能会对你的包名有意见，特别是如果它不明确或可能与其他东西混淆时。通常，您会得到一个可能更适合您的包的新名称的建议。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"避免行话。特别是要避免使用首字母缩略词，除非混淆的可能性很小。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"如果您在谈论美国，可以使用 USA。\n即使您在谈论积极的心态，也不能使用 PMA。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"避免在你的包名中使用 Julia 或在它前面加上 Ju。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"您的用户通常可以从上下文中清楚地知道该包是 Julia 包。\n包名称已经有一个 .jl 扩展，它向用户表明了 Package.jl 是个Julia 包。\n名称中包含 Julia 可能意味着该包与 Julia 语言本身的贡献者相关或由其认可。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"提供与新类型相关的大部分功能的包应该具有英文单词复数形式的名称。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"DataFrames 提供 DataFrame 类型。\nBloomFilters 提供 BloomFilter 类型。\n相比之下，JuliaParser 不提供新类型，而是在函数 JuliaParser.parse() 中提供新功能。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"在清晰的表达方面犯错，因为清晰的表达在你看来可能更冗长。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"RandomMatrices 是一个比 RndMator 或 RMT更明确的名称 ，即使后者更短。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"不太系统的名称可能适合实现其领域内的几种可能方法之一的包。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"Julia 没有单一的综合绘图包。相反，Gadfly、PyPlot、Winston 和其他包都实现了基于特定设计理念的独特方法。\n相反，SortingAlgorithms 提供了一个一致的接口来使用许多成熟的排序算法。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"包装外部库或程序的包应以这些库或程序命名。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"CPLEX.jl 包装了 CPLEX 库, 它可以在 web 搜索中轻松识别。\nMATLAB.jl 提供从 Julia 内部调用 MATLAB 引擎的接口。","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"避免与现有包相似的名称\nWebsocket 和 WebSockets 太相似，容易被用户混淆。 应该使用新名称，例如 SimpleWebsockets。","category":"page"},{"location":"creating-packages/#注册包","page":"5. 创建包","title":"注册包","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"一旦一个包准备好了，它就可以在General Registry注册表中注册（另请参阅FAQ）。目前，包是通过Registrator提交的。 此外 Registrator，TagBot帮助管理标记发布的过程。","category":"page"},{"location":"creating-packages/#最佳实践","page":"5. 创建包","title":"最佳实践","text":"","category":"section"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"包应该避免改变自己的状态（写入包目录中的文件）。一般来说，包不应该假设它们位于可写位置（例如，作为系统级 depot 的一部分安装）甚至是稳定的位置（例如，它们通过PackageCompiler.jl捆绑到系统映像中）。为了支持 Julia 包生态系统中的各种用例，Pkg 开发人员创建了许多辅助包和技术来帮助包作者创建自包含、不可变和可重定位的包：","category":"page"},{"location":"creating-packages/","page":"5. 创建包","title":"5. 创建包","text":"Artifacts可用于将数据块与您的包捆绑在一起，甚至允许它们按需下载。相比尝试通过诸如 joinpath(@__DIR__, \"data\", \"my_dataset.csv\") 不可重定位的路径打开文件，artifacts 更优雅。一旦你的包被预编译，@__DIR__的结果将被自动加入到你的预编译包数据中，如果你尝试分发这个包，它会尝试在错误的位置加载文件。可以使用 artifact\"name\" 字符串宏轻松绑定和访问 Artifacts。\nScratch.jl提供“暂存空间”的概念，即包的可变数据容器。暂存空间专为完全由包管理的数据缓存而设计，在卸载包时应将其删除。对于重要的用户生成的数据，包应继续写入到用户指定的路径，该路径不受 Julia 或 Pkg 管理。\nPreferences.jl允许包读写选项偏好(preferences)到顶级 Project.toml. 这些选项偏好可以在运行时或编译时读取，以启用或禁用包行为的不同方面。以前，包会将文件写入自己的包目录以记录用户或环境设置的选项，但现在非常不鼓励这样做，使用 Preferences 可以做的更好。","category":"page"},{"location":"repl/#REPL-Mode-Reference","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"","category":"section"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"This section describes available commands in the Pkg REPL. The Pkg REPL mode is mostly meant for interactive use, and for non-interactive use it is recommended to use the functional API, see API Reference.","category":"page"},{"location":"repl/#package-commands","page":"11. REPL Mode Reference","title":"package commands","text":"","category":"section"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-add\" href=\"#repl-add\">\n            <code>add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"add\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-build\" href=\"#repl-build\">\n            <code>build</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"build\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-compat\" href=\"#repl-compat\">\n            <code>compat</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"compat\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-develop\" href=\"#repl-develop\">\n            <code>develop</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"develop\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-free\" href=\"#repl-free\">\n            <code>free</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"free\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-generate\" href=\"#repl-generate\">\n            <code>generate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"generate\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-pin\" href=\"#repl-pin\">\n            <code>pin</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"pin\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-remove\" href=\"#repl-remove\">\n            <code>remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"remove\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-test\" href=\"#repl-test\">\n            <code>test</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"test\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-update\" href=\"#repl-update\">\n            <code>update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"update\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/#registry-commands","page":"11. REPL Mode Reference","title":"registry commands","text":"","category":"section"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-add\" href=\"#repl-registry-add\">\n            <code>registry add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry add\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-remove\" href=\"#repl-registry-remove\">\n            <code>registry remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry remove\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-status\" href=\"#repl-registry-status\">\n            <code>registry status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry status\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-update\" href=\"#repl-registry-update\">\n            <code>registry update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry update\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/#Other-commands","page":"11. REPL Mode Reference","title":"Other commands","text":"","category":"section"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-activate\" href=\"#repl-activate\">\n            <code>activate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"activate\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-gc\" href=\"#repl-gc\">\n            <code>gc</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"gc\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-help\" href=\"#repl-help\">\n            <code>help</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"help\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-instantiate\" href=\"#repl-instantiate\">\n            <code>instantiate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"instantiate\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-precompile\" href=\"#repl-precompile\">\n            <code>precompile</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"precompile\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-resolve\" href=\"#repl-resolve\">\n            <code>resolve</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"resolve\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-status\" href=\"#repl-status\">\n            <code>status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"status\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"#**1.**-简介","page":"1. 简介","title":"1. 简介","text":"","category":"section"},{"location":"","page":"1. 简介","title":"1. 简介","text":"欢迎来到Julia的包管理器Pkg的文档。文档包含如管理软件包安装，开发软件包，使用软件包注册表等事项。","category":"page"},{"location":"","page":"1. 简介","title":"1. 简介","text":"在整个手册中，示例使用了Pkg的REPL接口，即Pkg REPL模式。还有一个函数式 API，在非交互式工作时最好使用它。这个 API 在 API Reference部分有文档说明。","category":"page"},{"location":"#背景和设计","page":"1. 简介","title":"背景和设计","text":"","category":"section"},{"location":"","page":"1. 简介","title":"1. 简介","text":"不像传统的包管理器，安装和管理一个全局的软件包集合，Pkg是围绕“environments(环境)”设计的： 独立的软件包集合可以是单个项目本地的，也可以通过名称共享和选择。 环境中的包和版本的确切集合被捕获在一个 manifest 文件中，可以将其签入项目存储库并在版本控制中进行跟踪，从而显着提高项目的可复现性。如果您曾经尝试运行一段时间未使用的代码，却发现由于更新或卸载了项目正在使用的一些包而无法正常工作，那么您将了解这种方法的动机。在 Pkg 中，由于每个项目都维护自己独立的软件包版本集，因此您将永远不会再遇到此问题。此外，如果您在一个新系统上检出(checkout)一个项目，您可以简单地实现其 manifest 文件描述的环境，立即启动并运行一组已知良好的依赖项。","category":"page"},{"location":"","page":"1. 简介","title":"1. 简介","text":"由于环境是相互独立管理和更新的 ，因此 Pkg 中的“依赖地狱”得到了显着缓解。如果你想在一个新项目中使用某个包的最新和最好的版本，但是你在另一个项目中被困在一个旧版本上，那也没问题——因为它们有不同的环境，它们可以使用不同的版本，这两者同时安装在系统的不同位置。每个包版本的位置都是规范的，所以当环境使用相同版本的包时，它们可以共享安装，避免不必要的包重复。不再被任何环境使用的旧版本包由包管理器定期进行“垃圾收集”。","category":"page"},{"location":"","page":"1. 简介","title":"1. 简介","text":"Pkg 处理本地环境的方法对于使用过 Python virtualenv 或 Ruby bundler 的人来说可能比较熟悉。在 Julia 中，我们没有hacking语言的代码加载机制来支持环境，而是受益于 Julia 原生地理解它们。此外，Julia 环境是“stackable”的：您可以用一个环境覆盖另一个环境，从而可以访问主环境之外的其他包。这使得在提供主要环境的项目上工作变得容易，同时仍然可以从 REPL 访问所有常用的开发工具，如分析器、调试器等，只需在 load path 中有一个包含这些开发工具的环境。","category":"page"},{"location":"","page":"1. 简介","title":"1. 简介","text":"最后但同样重要的是，Pkg 旨在支持联合的包注册表。这意味着它允许由不同方管理的多个注册表无缝交互。特别是，这包括可以存在于公司防火墙后面的私有注册表。您可以使用与安装和管理官方 Julia 包完全相同的工具和工作流程，从私有注册表安装和更新自己的包。如果您迫切需要为您公司的重要产品使用的公共软件包应用补丁程序，您可以在公司的内部注册表中标记它的私有版本，并轻松快速地为您的开发人员和运营团队获取修复程序，而无需等待上游补丁的接收和发布。并且，一旦官方发布了修复程序，您只需升级您的依赖项，就可以再次回到官方的发行版本上。","category":"page"}]
}
